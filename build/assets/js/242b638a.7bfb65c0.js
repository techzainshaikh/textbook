"use strict";(globalThis.webpackChunkphysical_ai_book_humanoid=globalThis.webpackChunkphysical_ai_book_humanoid||[]).push([[13],{80(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"module-1-ros2/chapter-1-exercises","title":"Chapter 1 - Exercises","description":"Exercises for ROS 2 communication patterns in humanoid robotics","source":"@site/docs/module-1-ros2/chapter-1-exercises.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-1-exercises","permalink":"/docs/module-1-ros2/chapter-1-exercises","draft":false,"unlisted":false,"editUrl":"https://github.com/Panaversity/physical_ai_book_humanoid/tree/main/docs/module-1-ros2/chapter-1-exercises.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Chapter 1 - Exercises","description":"Exercises for ROS 2 communication patterns in humanoid robotics","keywords":["ros2","exercises","communication","patterns","robotics"]},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1 - Nodes, Topics, Services, Actions","permalink":"/docs/module-1-ros2/chapter-1-nodes-topics-services"},"next":{"title":"Chapter 2 - rclpy-based Python Agents","permalink":"/docs/module-1-ros2/chapter-2-rclpy-agents"}}');var s=i(4848),o=i(8453);const r={sidebar_position:6,title:"Chapter 1 - Exercises",description:"Exercises for ROS 2 communication patterns in humanoid robotics",keywords:["ros2","exercises","communication","patterns","robotics"]},a="Chapter 1 - Exercises",c={},l=[{value:"Conceptual Exercises",id:"conceptual-exercises",level:2},{value:"Exercise 1: Communication Pattern Analysis",id:"exercise-1-communication-pattern-analysis",level:3},{value:"Exercise 2: Node Design Principles",id:"exercise-2-node-design-principles",level:3},{value:"Logical Exercises",id:"logical-exercises",level:2},{value:"Exercise 3: Topic Message Design",id:"exercise-3-topic-message-design",level:3},{value:"Exercise 4: Service Interface Design",id:"exercise-4-service-interface-design",level:3},{value:"Implementation Exercises",id:"implementation-exercises",level:2},{value:"Exercise 5: Basic Publisher-Subscriber Pair",id:"exercise-5-basic-publisher-subscriber-pair",level:3},{value:"Exercise 6: Service Implementation",id:"exercise-6-service-implementation",level:3},{value:"Exercise 7: Action Implementation",id:"exercise-7-action-implementation",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-1---exercises",children:"Chapter 1 - Exercises"})}),"\n",(0,s.jsx)(n.h2,{id:"conceptual-exercises",children:"Conceptual Exercises"}),"\n",(0,s.jsx)(n.h3,{id:"exercise-1-communication-pattern-analysis",children:"Exercise 1: Communication Pattern Analysis"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty"}),": Beginner"]}),"\n",(0,s.jsx)(n.p,{children:"Compare and contrast the four main ROS 2 communication patterns (nodes, topics, services, actions) in the context of humanoid robotics. For each pattern, identify at least two specific use cases in a humanoid robot system and explain why that pattern is appropriate for the use case."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Topics"}),": Used for sensor data streams (IMU, camera feeds) and robot state publishing. Appropriate for asynchronous, many-to-many communication where publishers don't need responses."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Services"}),": Used for calibration requests and configuration changes. Appropriate for synchronous request-response operations requiring definitive results."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Actions"}),": Used for navigation and manipulation tasks. Appropriate for long-running operations requiring feedback and cancellation capabilities."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"exercise-2-node-design-principles",children:"Exercise 2: Node Design Principles"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty"}),": Intermediate"]}),"\n",(0,s.jsx)(n.p,{children:"Design a node architecture for a humanoid robot's walking controller. Identify the different nodes needed, their responsibilities, and how they communicate with each other. Discuss potential issues with tight coupling and how to avoid them."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":\nA walking controller architecture might include:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Gait generator node (publishes step targets)"}),"\n",(0,s.jsx)(n.li,{children:"Balance controller node (publishes corrective commands)"}),"\n",(0,s.jsx)(n.li,{children:"Joint trajectory controller node (executes commands)"}),"\n",(0,s.jsx)(n.li,{children:"State estimator node (publishes current state)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Communication should be via topics for real-time data and services for configuration changes."}),"\n",(0,s.jsx)(n.h2,{id:"logical-exercises",children:"Logical Exercises"}),"\n",(0,s.jsx)(n.h3,{id:"exercise-3-topic-message-design",children:"Exercise 3: Topic Message Design"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty"}),": Intermediate"]}),"\n",(0,s.jsx)(n.p,{children:"Design appropriate message types for a humanoid robot's walking control system. Consider the information needed for step planning, balance feedback, and coordination between different control modules. Justify your design choices."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":\nFor step planning: geometry_msgs/PoseStamped for target foot positions\nFor balance feedback: sensor_msgs/Imu for orientation data and geometry_msgs/Point for center of mass\nFor coordination: custom message with step timing, support foot, and gait phase information"]}),"\n",(0,s.jsx)(n.h3,{id:"exercise-4-service-interface-design",children:"Exercise 4: Service Interface Design"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty"}),": Advanced"]}),"\n",(0,s.jsx)(n.p,{children:"Design a service interface for a humanoid robot's emergency stop system. The service should handle different types of emergencies (balance loss, joint overheating, collision detection) and provide appropriate responses. Consider safety implications and recovery procedures."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":\nRequest: emergency type, severity level, affected components\nResponse: action taken, recovery status, estimated time to resume\nIncludes provisions for different emergency types and appropriate safety responses."]}),"\n",(0,s.jsx)(n.h2,{id:"implementation-exercises",children:"Implementation Exercises"}),"\n",(0,s.jsx)(n.h3,{id:"exercise-5-basic-publisher-subscriber-pair",children:"Exercise 5: Basic Publisher-Subscriber Pair"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty"}),": Beginner"]}),"\n",(0,s.jsx)(n.p,{children:"Implement a publisher-subscriber pair where the publisher sends joint position commands at 10Hz and the subscriber logs the received commands. Both nodes should handle graceful shutdown when interrupted. Include proper error handling and logging."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Publisher Implementation\n# WHAT: This code creates a publisher that sends joint position commands\n# WHY: To demonstrate basic topic communication in ROS 2\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray\nimport math\nimport time\n\nclass JointCommandPublisher(Node):\n    def __init__(self):\n        super().__init__('joint_command_publisher')\n\n        # Create publisher for joint commands\n        # WHAT: This creates a publisher that sends joint position commands\n        # WHY: The robot needs to receive desired joint positions to execute movements\n        self.publisher = self.create_publisher(Float64MultiArray, 'joint_commands', 10)\n\n        # Timer to send commands at 10Hz\n        # WHAT: This timer callback executes every 0.1 seconds to send new commands\n        # WHY: Consistent timing is important for smooth robot motion control\n        self.timer = self.create_timer(0.1, self.timer_callback)\n\n        # Counter for generating different command values\n        self.counter = 0\n\n        self.get_logger().info('Joint Command Publisher node initialized')\n\n    def timer_callback(self):\n        \"\"\"Publish joint position commands at regular intervals\"\"\"\n        # Create message to hold joint commands\n        # WHAT: This creates a Float64MultiArray message containing joint position commands\n        # WHY: The Float64MultiArray is a flexible message type for sending multiple numerical values\n        msg = Float64MultiArray()\n\n        # Generate a pattern of joint positions using sine waves\n        # WHAT: This generates smooth, oscillating joint position commands\n        # WHY: Using sine waves creates natural-looking motion patterns for demonstration\n        joint_positions = []\n        for i in range(6):  # Example: 6 joints\n            position = 0.5 * math.sin(self.counter * 0.1 + i * math.pi / 3)\n            joint_positions.append(position)\n\n        msg.data = joint_positions\n\n        # Publish the joint command message\n        # WHAT: This publishes the joint position commands to the 'joint_commands' topic\n        # WHY: Other nodes (like the robot controller) subscribe to this topic to receive commands\n        self.publisher.publish(msg)\n\n        # Log the published values for debugging\n        self.get_logger().info(f'Published joint commands: {msg.data}')\n\n        # Increment counter for next iteration\n        self.counter += 1\n\ndef main(args=None):\n    \"\"\"Main function to initialize and run the ROS 2 publisher node\"\"\"\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n\n    # Create an instance of the JointCommandPublisher node\n    # WHAT: This creates the publisher node instance\n    # WHY: The node contains all the logic for publishing joint commands\n    joint_publisher = JointCommandPublisher()\n\n    try:\n        # Start spinning the node to process callbacks\n        # WHAT: This starts the ROS 2 event loop, processing timer callbacks and other events\n        # WHY: Without spinning, the node wouldn't execute its timer callback to publish commands\n        rclpy.spin(joint_publisher)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        # WHAT: This handles the case when the user interrupts the program\n        # WHY: Provides a clean way to stop the publisher when needed\n        joint_publisher.get_logger().info('Shutting down joint command publisher')\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        joint_publisher.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Dependencies"}),": ",(0,s.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,s.jsx)(n.code,{children:"std_msgs"})]}),"\n",(0,s.jsx)(n.h3,{id:"exercise-6-service-implementation",children:"Exercise 6: Service Implementation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty"}),": Intermediate"]}),"\n",(0,s.jsx)(n.p,{children:"Implement a service that calibrates a humanoid robot's joint encoders. The service should simulate the calibration process, return success/failure status, and include proper error handling for different failure modes."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Service Implementation\n# WHAT: This code creates a service that calibrates humanoid robot joint encoders\n# WHY: To demonstrate service implementation with proper error handling and status reporting\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile\nfrom example_interfaces.srv import Trigger\nimport time\nimport random\n\nclass JointCalibrationService(Node):\n    def __init__(self):\n        super().__init__('joint_calibration_service')\n\n        # Create service for joint calibration\n        # WHAT: This creates a service that handles joint calibration requests\n        # WHY: Services are ideal for operations that require a definitive response\n        self.srv = self.create_service(\n            Trigger,\n            'calibrate_joints',\n            self.calibrate_joints_callback\n        )\n\n        # Store calibration status for each joint\n        self.calibration_status = {}\n        self.joint_names = [\n            'left_hip', 'left_knee', 'left_ankle',\n            'right_hip', 'right_knee', 'right_ankle',\n            'left_shoulder', 'left_elbow', 'right_shoulder', 'right_elbow'\n        ]\n\n        # Initialize all joints as uncalibrated\n        for joint_name in self.joint_names:\n            self.calibration_status[joint_name] = False\n\n        self.get_logger().info('Joint Calibration Service initialized')\n\n    def calibrate_joints_callback(self, request, response):\n        \"\"\"Handle joint calibration requests\"\"\"\n        # Log the calibration request\n        # WHAT: This logs that a calibration request has been received\n        # WHY: Logging helps with debugging and monitoring system behavior\n        self.get_logger().info('Received joint calibration request')\n\n        # Simulate the calibration process\n        # WHAT: This simulates the actual calibration procedure\n        # WHY: Real calibration would involve moving joints to known positions and setting encoders\n        try:\n            # Simulate calibration time\n            time.sleep(2.0)  # Simulate actual calibration time\n\n            # Simulate possible calibration failures\n            # WHAT: This simulates potential failure conditions during calibration\n            # WHY: Real systems must handle various failure modes gracefully\n            if random.random() < 0.1:  # 10% chance of failure\n                response.success = False\n                response.message = 'Calibration failed due to encoder error'\n                self.get_logger().error(response.message)\n                return response\n\n            # Mark all joints as calibrated\n            # WHAT: This updates the calibration status for all joints\n            # WHY: Successful calibration means joints are properly calibrated\n            for joint_name in self.joint_names:\n                self.calibration_status[joint_name] = True\n\n            response.success = True\n            response.message = f'Successfully calibrated {len(self.joint_names)} joints'\n            self.get_logger().info(response.message)\n\n        except Exception as e:\n            # Handle any errors during calibration\n            # WHAT: This catches and handles any exceptions during the calibration process\n            # WHY: Error handling ensures the service doesn't crash and provides useful feedback\n            response.success = False\n            response.message = f'Calibration failed: {str(e)}'\n            self.get_logger().error(response.message)\n\n        return response\n\ndef main(args=None):\n    \"\"\"Main function to initialize and run the ROS 2 service node\"\"\"\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n\n    # Create an instance of the JointCalibrationService node\n    # WHAT: This creates the service node instance\n    # WHY: The node contains all the logic for handling calibration requests\n    calibration_service = JointCalibrationService()\n\n    try:\n        # Start spinning the node to process service requests\n        # WHAT: This starts the ROS 2 event loop, processing incoming service requests\n        # WHY: Without spinning, the node wouldn't execute its service callback functions\n        rclpy.spin(calibration_service)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        # WHAT: This handles the case when the user interrupts the program\n        # WHY: Provides a clean way to stop the service when needed\n        calibration_service.get_logger().info('Shutting down joint calibration service')\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        calibration_service.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Dependencies"}),": ",(0,s.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,s.jsx)(n.code,{children:"example_interfaces"})]}),"\n",(0,s.jsx)(n.h3,{id:"exercise-7-action-implementation",children:"Exercise 7: Action Implementation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty"}),": Advanced"]}),"\n",(0,s.jsx)(n.p,{children:"Implement an action for humanoid robot navigation that includes feedback during execution, result reporting, and cancellation capability. The action should simulate the navigation process with realistic timing and potential interruptions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Action Implementation\n# WHAT: This code creates an action for humanoid robot navigation tasks\n# WHY: To demonstrate long-running tasks with feedback, results, and cancellation\n\nimport rclpy\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Pose, Point\nfrom nav2_msgs.action import NavigateToPose\nimport time\nimport math\n\nclass HumanoidNavigationAction(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_navigation_action\')\n\n        # Create action server for navigation\n        # WHAT: This creates an action server for navigation tasks\n        # WHY: Actions are ideal for long-running operations requiring feedback and cancellation\n        self._action_server = ActionServer(\n            self,\n            NavigateToPose,\n            \'navigate_to_pose\',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback\n        )\n\n        # Store current robot pose\n        self.current_pose = Pose()\n        self.current_pose.position.x = 0.0\n        self.current_pose.position.y = 0.0\n        self.current_pose.position.z = 0.0\n        self.current_pose.orientation.w = 1.0  # No rotation initially\n\n        self.get_logger().info(\'Humanoid Navigation Action server initialized\')\n\n    def goal_callback(self, goal_request):\n        """Accept all goals for simplicity"""\n        # WHAT: This callback determines if a navigation goal should be accepted\n        # WHY: Allows the server to reject goals that are not feasible\n        self.get_logger().info(\'Received navigation goal\')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        """Accept all cancellation requests"""\n        # WHAT: This callback determines if a goal cancellation should be accepted\n        # WHY: Allows the server to control when goals can be cancelled\n        self.get_logger().info(\'Received cancel request\')\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        """Execute the navigation goal"""\n        # Log the start of navigation execution\n        # WHAT: This logs that navigation has started\n        # WHY: Provides feedback on the action\'s progress for debugging\n        self.get_logger().info(\'Executing navigation goal...\')\n\n        # Get target position from the goal request\n        # WHAT: This extracts the target coordinates from the goal\n        # WHY: The navigation algorithm needs to know where to go\n        target_x = goal_handle.request.pose.pose.position.x\n        target_y = goal_handle.request.pose.pose.position.y\n\n        # Simulate navigation with feedback\n        # WHAT: This creates feedback and result messages for the action\n        # WHY: Actions require specific message types for feedback and results\n        feedback_msg = NavigateToPose.Feedback()\n        result = NavigateToPose.Result()\n\n        # Simulate moving toward the goal\n        # WHAT: This initializes the current position for the simulation\n        # WHY: Navigation starts from the current position\n        current_x = self.current_pose.position.x\n        current_y = self.current_pose.position.y\n        step_size = 0.1  # Meters per feedback step\n        total_distance = math.sqrt((target_x - current_x)**2 + (target_y - current_y)**2)\n\n        while goal_handle.is_cancel_requested is False:\n            # Calculate distance to goal\n            # WHAT: This calculates how far the robot is from the target\n            # WHY: Needed to determine when the goal is reached\n            dist_to_goal = math.sqrt((target_x - current_x)**2 + (target_y - current_y)**2)\n\n            if dist_to_goal < 0.1:  # Close enough to goal\n                # Goal reached successfully\n                # WHAT: This indicates the navigation was successful\n                # WHY: The result message needs to indicate success or failure\n                result.result = True\n                goal_handle.succeed()\n                self.get_logger().info(\'Navigation completed successfully\')\n\n                # Update current pose to target\n                self.current_pose.position.x = target_x\n                self.current_pose.position.y = target_y\n\n                return result\n\n            # Move closer to goal\n            # WHAT: This calculates the direction and moves the robot\n            # WHY: The robot needs to continuously move toward the target\n            direction_x = (target_x - current_x) / dist_to_goal\n            direction_y = (target_y - current_y) / dist_to_goal\n\n            current_x += direction_x * step_size\n            current_y += direction_y * step_size\n\n            # Update feedback\n            # WHAT: This sends feedback to the action client about progress\n            # WHY: Clients need to know the current status of the long-running action\n            feedback_msg.current_pose.pose.position.x = current_x\n            feedback_msg.current_pose.pose.position.y = current_y\n            feedback_msg.distance_remaining = dist_to_goal\n\n            goal_handle.publish_feedback(feedback_msg)\n\n            # Sleep to simulate processing time\n            # WHAT: This simulates the time it takes to move the robot\n            # WHY: Real navigation would take actual time to execute\n            time.sleep(0.5)\n\n        # Check if goal was canceled\n        # WHAT: This handles the case where the goal was canceled\n        # WHY: The action needs to properly handle cancellation requests\n        if goal_handle.is_cancel_requested:\n            result.result = False\n            goal_handle.canceled()\n            self.get_logger().info(\'Navigation canceled\')\n            return result\n\ndef main(args=None):\n    """Main function to initialize and run the ROS 2 action server"""\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n    navigation_action = HumanoidNavigationAction()\n\n    try:\n        # Start spinning the node to process action requests\n        # WHAT: This starts the ROS 2 event loop, processing incoming action requests\n        # WHY: Without spinning, the node wouldn\'t execute its action callback functions\n        rclpy.spin(navigation_action)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        # WHAT: This handles the case when the user interrupts the program\n        # WHY: Provides a clean way to stop the action server when needed\n        navigation_action.get_logger().info(\'Shutting down navigation action server\')\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        navigation_action.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Dependencies"}),": ",(0,s.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,s.jsx)(n.code,{children:"geometry_msgs"}),", ",(0,s.jsx)(n.code,{children:"nav2_msgs"})]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"These exercises cover the fundamental ROS 2 communication patterns with increasing complexity from basic publisher/subscriber pairs to advanced action servers. Each exercise includes both conceptual understanding and practical implementation, reinforcing the core concepts of ROS 2 communication in humanoid robotics."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);