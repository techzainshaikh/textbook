"use strict";(globalThis.webpackChunkphysical_ai_book_humanoid=globalThis.webpackChunkphysical_ai_book_humanoid||[]).push([[695],{8453(e,n,t){t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}},8711(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-1-ros2/chapter-2-exercises","title":"Chapter 2 - Exercises","description":"Exercises for rclpy-based Python agents in humanoid robotics","source":"@site/docs/module-1-ros2/chapter-2-exercises.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-2-exercises","permalink":"/docs/module-1-ros2/chapter-2-exercises","draft":false,"unlisted":false,"editUrl":"https://github.com/Panaversity/physical_ai_book_humanoid/tree/main/docs/module-1-ros2/chapter-2-exercises.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Chapter 2 - Exercises","description":"Exercises for rclpy-based Python agents in humanoid robotics","keywords":["rclpy","python","agents","exercises","humanoid","control"]},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2 - rclpy-based Python Agents","permalink":"/docs/module-1-ros2/chapter-2-rclpy-agents"},"next":{"title":"Chapter 3 - URDF Humanoid Modeling","permalink":"/docs/module-1-ros2/chapter-3-urdf-modeling"}}');var r=t(4848),a=t(8453);const i={sidebar_position:7,title:"Chapter 2 - Exercises",description:"Exercises for rclpy-based Python agents in humanoid robotics",keywords:["rclpy","python","agents","exercises","humanoid","control"]},o="Chapter 2 - Exercises",l={},c=[{value:"Conceptual Exercises",id:"conceptual-exercises",level:2},{value:"Exercise 1: Agent Architecture Design",id:"exercise-1-agent-architecture-design",level:3},{value:"Exercise 2: State Machine Design",id:"exercise-2-state-machine-design",level:3},{value:"Logical Exercises",id:"logical-exercises",level:2},{value:"Exercise 3: Agent Coordination Logic",id:"exercise-3-agent-coordination-logic",level:3},{value:"Exercise 4: Error Propagation Analysis",id:"exercise-4-error-propagation-analysis",level:3},{value:"Implementation Exercises",id:"implementation-exercises",level:2},{value:"Exercise 5: Basic Agent Implementation",id:"exercise-5-basic-agent-implementation",level:3},{value:"Exercise 6: State Machine Agent",id:"exercise-6-state-machine-agent",level:3},{value:"Exercise 7: Multi-Agent Coordination",id:"exercise-7-multi-agent-coordination",level:3},{value:"Summary",id:"summary",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-2---exercises",children:"Chapter 2 - Exercises"})}),"\n",(0,r.jsx)(n.h2,{id:"conceptual-exercises",children:"Conceptual Exercises"}),"\n",(0,r.jsx)(n.h3,{id:"exercise-1-agent-architecture-design",children:"Exercise 1: Agent Architecture Design"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Difficulty"}),": Intermediate"]}),"\n",(0,r.jsx)(n.p,{children:"Design an agent architecture for a humanoid robot's walking controller. Identify the different agents needed, their responsibilities, and how they communicate with each other. Consider state management, error handling, and recovery mechanisms. Draw a diagram showing the agent interactions."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),":\nA walking controller architecture might include:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Balance controller agent (maintains stability)"}),"\n",(0,r.jsx)(n.li,{children:"Step planner agent (plans foot placement)"}),"\n",(0,r.jsx)(n.li,{children:"Trajectory generator agent (generates joint trajectories)"}),"\n",(0,r.jsx)(n.li,{children:"State estimator agent (tracks current state)"}),"\n",(0,r.jsx)(n.li,{children:"Safety monitor agent (detects and handles errors)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"exercise-2-state-machine-design",children:"Exercise 2: State Machine Design"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Difficulty"}),": Advanced"]}),"\n",(0,r.jsx)(n.p,{children:"Design a state machine for a humanoid robot's walking behavior. Identify the different states, transitions, and triggers. Consider how to handle disturbances, emergencies, and transitions between different walking gaits (standing, walking, turning, stopping)."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),":\nStates: STANDING, PREPARING_STEP, STEPPING, BALANCING, EMERGENCY_STOP\nTransitions triggered by: sensor data, commands, error conditions, completion of actions"]}),"\n",(0,r.jsx)(n.h2,{id:"logical-exercises",children:"Logical Exercises"}),"\n",(0,r.jsx)(n.h3,{id:"exercise-3-agent-coordination-logic",children:"Exercise 3: Agent Coordination Logic"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Difficulty"}),": Intermediate"]}),"\n",(0,r.jsx)(n.p,{children:"Implement the logic for coordinating multiple agents in a humanoid robot system. Design how agents share information, handle conflicts, and maintain consistency. Consider priority-based conflict resolution and failover mechanisms."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),":\nCoordination logic includes: shared state management, priority-based command arbitration, heartbeat monitoring, and graceful degradation when agents fail."]}),"\n",(0,r.jsx)(n.h3,{id:"exercise-4-error-propagation-analysis",children:"Exercise 4: Error Propagation Analysis"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Difficulty"}),": Advanced"]}),"\n",(0,r.jsx)(n.p,{children:"Analyze how errors in one agent can propagate through a multi-agent system. Design isolation mechanisms and error containment strategies to prevent cascading failures. Consider both software and hardware failure scenarios."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),":\nError isolation includes: agent boundaries with timeouts, circuit breakers, graceful degradation, and fallback behaviors when components fail."]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-exercises",children:"Implementation Exercises"}),"\n",(0,r.jsx)(n.h3,{id:"exercise-5-basic-agent-implementation",children:"Exercise 5: Basic Agent Implementation"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Difficulty"}),": Beginner"]}),"\n",(0,r.jsx)(n.p,{children:"Implement a basic agent that monitors joint temperatures and implements a safety system that reduces motor power when temperatures exceed safe thresholds. Include proper logging and error handling."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Basic Agent Implementation\n# WHAT: This code creates an agent that monitors joint temperatures and implements safety controls\n# WHY: To demonstrate basic agent concepts with monitoring, safety controls, and error handling\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Temperature\nfrom std_msgs.msg import Float64MultiArray, String\nfrom builtin_interfaces.msg import Time\nimport time\nfrom enum import Enum\nfrom typing import Dict, List\n\nclass SafetyState(Enum):\n    """Enumeration of safety states"""\n    SAFE = "safe"\n    WARNING = "warning"\n    ERROR = "error"\n    EMERGENCY_STOP = "emergency_stop"\n\nclass JointTemperatureMonitorAgent(Node):\n    def __init__(self):\n        super().__init__(\'joint_temperature_monitor_agent\')\n\n        # Agent state management\n        # WHAT: These variables track the current safety state of the agent\n        # WHY: State management is crucial for handling different safety levels\n        self.safety_state = SafetyState.SAFE\n        self.last_error_time = None\n\n        # Joint temperature storage\n        # WHAT: Store current temperatures for each joint\n        # WHY: Temperatures need to be monitored for safety\n        self.joint_temperatures = {}\n        self.joint_names = [\n            \'left_hip\', \'left_knee\', \'left_ankle\',\n            \'right_hip\', \'right_knee\', \'right_ankle\',\n            \'left_shoulder\', \'left_elbow\',\n            \'right_shoulder\', \'right_elbow\'\n        ]\n\n        # Initialize temperatures\n        for joint_name in self.joint_names:\n            self.joint_temperatures[joint_name] = 25.0  # Default temperature\n\n        # Temperature thresholds\n        # WHAT: Define safe temperature limits for each joint\n        # WHY: Exceeding temperature limits can damage motors and other components\n        self.warning_threshold = 60.0  # Celsius\n        self.error_threshold = 70.0    # Celsius\n\n        # Publishers and subscribers\n        # WHAT: Create publisher for safety status and subscriber for temperature data\n        # WHY: Communication with other nodes is essential for coordinated safety\n        self.safety_status_publisher = self.create_publisher(String, \'/safety_status\', 10)\n        self.temperature_subscriber = self.create_subscription(\n            Temperature, \'/joint_temperatures\', self.temperature_callback, 10\n        )\n        self.power_reduction_publisher = self.create_publisher(Float64MultiArray, \'/power_reduction\', 10)\n\n        # Timer for safety monitoring\n        # WHAT: Create a timer to periodically check temperatures\n        # WHY: Continuous monitoring is needed for safety\n        self.monitor_timer = self.create_timer(1.0, self.safety_check)\n\n        self.get_logger().info(\'Joint Temperature Monitor Agent initialized\')\n\n    def temperature_callback(self, msg: Temperature):\n        """Process temperature messages from joints"""\n        # WHAT: This method processes incoming temperature messages\n        # WHY: Temperature data is needed for safety monitoring\n        if hasattr(msg, \'name\') and hasattr(msg, \'temperature\'):\n            joint_name = msg.name\n            temperature = msg.temperature\n\n            if joint_name in self.joint_temperatures:\n                self.joint_temperatures[joint_name] = temperature\n                self.get_logger().debug(f\'Temperature for {joint_name}: {temperature}\xb0C\')\n\n    def safety_check(self):\n        """Check temperatures and update safety state"""\n        # WHAT: This method checks all joint temperatures and updates the safety state\n        # WHY: Regular safety checks ensure temperatures remain within safe limits\n        max_temp = max(self.joint_temperatures.values())\n\n        # Update safety state based on maximum temperature\n        # WHAT: Determine the safety state based on the highest temperature\n        # WHY: The overall safety state should reflect the most critical condition\n        if max_temp > self.error_threshold:\n            if self.safety_state != SafetyState.EMERGENCY_STOP:\n                self.safety_state = SafetyState.EMERGENCY_STOP\n                self.get_logger().error(f\'EMERGENCY STOP: Temperature {max_temp}\xb0C exceeds error threshold {self.error_threshold}\xb0C\')\n                self.publish_emergency_stop()\n        elif max_temp > self.warning_threshold:\n            if self.safety_state != SafetyState.ERROR:\n                self.safety_state = SafetyState.WARNING\n                self.get_logger().warning(f\'WARNING: Temperature {max_temp}\xb0C exceeds warning threshold {self.warning_threshold}\xb0C\')\n                self.publish_power_reduction()\n        else:\n            if self.safety_state != SafetyState.SAFE:\n                self.safety_state = SafetyState.SAFE\n                self.get_logger().info(\'All temperatures within safe limits\')\n\n        # Publish safety status\n        self.publish_safety_status()\n\n    def publish_safety_status(self):\n        """Publish current safety status"""\n        # WHAT: Publish the current safety status for other nodes to monitor\n        # WHY: Other nodes may need to know the safety state for coordinated behavior\n        status_msg = String()\n        status_msg.data = f"Temperature Safety Status: {self.safety_state.value}, Max Temp: {max(self.joint_temperatures.values()):.2f}\xb0C"\n        self.safety_status_publisher.publish(status_msg)\n\n    def publish_power_reduction(self):\n        """Publish power reduction commands"""\n        # WHAT: Send commands to reduce motor power when temperatures are high\n        # WHY: Reducing power helps decrease heat generation and cool down joints\n        reduction_msg = Float64MultiArray()\n        # Reduce power to 50% when in warning state\n        reduction_values = [0.5] * len(self.joint_names)\n        reduction_msg.data = reduction_values\n        self.power_reduction_publisher.publish(reduction_msg)\n\n    def publish_emergency_stop(self):\n        """Publish emergency stop commands"""\n        # WHAT: Send emergency stop commands when temperatures are critically high\n        # WHY: Immediate stop is needed to prevent damage when temperatures are critical\n        stop_msg = Float64MultiArray()\n        # Stop all joints when in emergency state\n        stop_values = [0.0] * len(self.joint_names)\n        stop_msg.data = stop_values\n        self.power_reduction_publisher.publish(stop_msg)\n\ndef main(args=None):\n    """Main function to initialize and run the temperature monitor agent"""\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n    agent = JointTemperatureMonitorAgent()\n\n    try:\n        # Start spinning the node to process callbacks\n        # WHAT: This starts the ROS 2 event loop, processing all callbacks\n        # WHY: Without spinning, the node wouldn\'t execute its timer and subscriber callbacks\n        rclpy.spin(agent)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        # WHAT: This handles the case when the user interrupts the program\n        # WHY: Provides a clean way to stop the agent when needed\n        agent.get_logger().info(\'Shutting down temperature monitor agent\')\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        agent.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dependencies"}),": ",(0,r.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,r.jsx)(n.code,{children:"sensor_msgs"}),", ",(0,r.jsx)(n.code,{children:"std_msgs"})]}),"\n",(0,r.jsx)(n.h3,{id:"exercise-6-state-machine-agent",children:"Exercise 6: State Machine Agent"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Difficulty"}),": Intermediate"]}),"\n",(0,r.jsx)(n.p,{children:"Implement an agent using a state machine pattern that controls a humanoid robot's posture transitions (standing, sitting, lying down). Include proper state transition logic, safety checks, and error recovery."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# State Machine Agent Implementation\n# WHAT: This code creates an agent that controls humanoid robot posture transitions using a state machine\n# WHY: To demonstrate state machine pattern for complex robot behaviors\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import String, Bool\nfrom geometry_msgs.msg import Twist\nfrom builtin_interfaces.msg import Time\nimport time\nfrom enum import Enum\nfrom typing import Dict, List\n\nclass PostureState(Enum):\n    \"\"\"Enumeration of possible posture states\"\"\"\n    STANDING = \"standing\"\n    SITTING = \"sitting\"\n    LYING_DOWN = \"lying_down\"\n    TRANSITIONING = \"transitioning\"\n    ERROR = \"error\"\n\nclass PostureControllerAgent(Node):\n    def __init__(self):\n        super().__init__('posture_controller_agent')\n\n        # State management\n        # WHAT: Track the current and target posture states\n        # WHY: State tracking is essential for proper posture control\n        self.current_state = PostureState.STANDING\n        self.target_state = PostureState.STANDING\n        self.previous_state = PostureState.STANDING\n        self.state_start_time = self.get_clock().now()\n\n        # Joint positions for each posture\n        # WHAT: Define joint positions for different postures\n        # WHY: Each posture requires specific joint angles for the robot\n        self.posture_positions = {\n            PostureState.STANDING: {\n                'left_hip': 0.0, 'left_knee': -0.5, 'left_ankle': 0.5,\n                'right_hip': 0.0, 'right_knee': -0.5, 'right_ankle': 0.5,\n                'left_shoulder': 0.0, 'left_elbow': -0.5,\n                'right_shoulder': 0.0, 'right_elbow': -0.5\n            },\n            PostureState.SITTING: {\n                'left_hip': 1.0, 'left_knee': -1.5, 'left_ankle': 0.5,\n                'right_hip': 1.0, 'right_knee': -1.5, 'right_ankle': 0.5,\n                'left_shoulder': 0.2, 'left_elbow': -1.0,\n                'right_shoulder': 0.2, 'right_elbow': -1.0\n            },\n            PostureState.LYING_DOWN: {\n                'left_hip': 0.0, 'left_knee': 0.0, 'left_ankle': 0.0,\n                'right_hip': 0.0, 'right_knee': 0.0, 'right_ankle': 0.0,\n                'left_shoulder': 1.0, 'left_elbow': 0.0,\n                'right_shoulder': 1.0, 'right_elbow': 0.0\n            }\n        }\n\n        # Current joint positions\n        self.current_positions = {name: 0.0 for name in self.posture_positions[PostureState.STANDING].keys()}\n        self.desired_positions = {name: 0.0 for name in self.posture_positions[PostureState.STANDING].keys()}\n\n        # Publishers and subscribers\n        # WHAT: Create publishers for commands and status, subscribers for state feedback\n        # WHY: Communication is needed for control and monitoring\n        self.joint_command_publisher = self.create_publisher(JointState, '/joint_commands', 10)\n        self.posture_status_publisher = self.create_publisher(String, '/posture_status', 10)\n        self.joint_state_subscriber = self.create_subscription(\n            JointState, '/joint_states', self.joint_state_callback, 10\n        )\n\n        # Command subscriber\n        self.command_subscriber = self.create_subscription(\n            String, '/posture_command', self.command_callback, 10\n        )\n\n        # Control timer\n        # WHAT: Create a timer to execute the state machine logic\n        # WHY: Regular execution is needed for state transitions and control\n        self.control_timer = self.create_timer(0.1, self.state_machine_step)\n\n        self.get_logger().info('Posture Controller Agent initialized in STANDING state')\n\n    def joint_state_callback(self, msg: JointState):\n        \"\"\"Update current joint positions\"\"\"\n        # WHAT: Process incoming joint state messages to update current positions\n        # WHY: Current positions are needed to determine transition progress\n        for i, name in enumerate(msg.name):\n            if name in self.current_positions and i < len(msg.position):\n                self.current_positions[name] = msg.position[i]\n\n    def command_callback(self, msg: String):\n        \"\"\"Handle posture change commands\"\"\"\n        # WHAT: Process commands to change postures\n        # WHY: External commands can trigger posture changes\n        command = msg.data.lower().strip()\n\n        if command == 'stand':\n            self.request_posture_transition(PostureState.STANDING)\n        elif command == 'sit':\n            self.request_posture_transition(PostureState.SITTING)\n        elif command == 'lie_down':\n            self.request_posture_transition(PostureState.LYING_DOWN)\n        else:\n            self.get_logger().warning(f'Unknown posture command: {command}')\n\n    def request_posture_transition(self, target_state: PostureState):\n        \"\"\"Request a transition to a new posture\"\"\"\n        # WHAT: Request a transition to a new posture\n        # WHY: Allow external requests to change the robot's posture\n        if self.current_state != PostureState.TRANSITIONING:\n            self.get_logger().info(f'Requesting transition from {self.current_state.value} to {target_state.value}')\n            self.target_state = target_state\n            self.previous_state = self.current_state\n            self.current_state = PostureState.TRANSITIONING\n            self.state_start_time = self.get_clock().now()\n\n            # Set desired positions for the target posture\n            for joint, position in self.posture_positions[target_state].items():\n                self.desired_positions[joint] = position\n        else:\n            self.get_logger().warning('Cannot initiate transition: already transitioning')\n\n    def state_machine_step(self):\n        \"\"\"Execute the state machine logic\"\"\"\n        # WHAT: Execute the current state's logic\n        # WHY: The state machine needs to run continuously to manage posture control\n        if self.current_state == PostureState.TRANSITIONING:\n            self.execute_transitioning_state()\n        elif self.current_state == PostureState.ERROR:\n            self.execute_error_state()\n        else:\n            # For stable states, just maintain position\n            for joint, position in self.posture_positions[self.current_state].items():\n                self.desired_positions[joint] = position\n\n        # Publish commands and status\n        self.publish_joint_commands()\n        self.publish_posture_status()\n\n    def execute_transitioning_state(self):\n        \"\"\"Execute the transitioning state logic\"\"\"\n        # WHAT: Manage the transition from current to target posture\n        # WHY: Transitions need to be smooth and controlled to avoid jerky movements\n        elapsed_time = (self.get_clock().now() - self.state_start_time).nanoseconds / 1e9\n\n        # Calculate transition progress (simplified linear interpolation)\n        # In a real implementation, this would use smoother interpolation\n        progress = min(elapsed_time / 3.0, 1.0)  # 3 seconds for transition\n\n        # Interpolate between current and target positions\n        for joint in self.desired_positions.keys():\n            current_pos = self.current_positions[joint]\n            target_pos = self.posture_positions[self.target_state][joint]\n            interpolated_pos = current_pos + (target_pos - current_pos) * progress\n            self.desired_positions[joint] = interpolated_pos\n\n        # Check if transition is complete\n        if progress >= 1.0:\n            self.current_state = self.target_state\n            self.get_logger().info(f'Completed transition to {self.current_state.value}')\n\n            # Set final positions\n            for joint, position in self.posture_positions[self.current_state].items():\n                self.desired_positions[joint] = position\n\n    def execute_error_state(self):\n        \"\"\"Execute the error state logic\"\"\"\n        # WHAT: Handle error conditions in the posture controller\n        # WHY: Errors need to be managed to maintain robot safety\n        self.get_logger().warning('Posture controller in ERROR state - maintaining current position')\n        # In error state, maintain current position or move to safe position\n\n    def publish_joint_commands(self):\n        \"\"\"Publish joint position commands\"\"\"\n        # WHAT: Send desired joint positions to the robot\n        # WHY: Commands must be sent to actuators for posture control\n        cmd_msg = JointState()\n        cmd_msg.header.stamp = self.get_clock().now().to_msg()\n        cmd_msg.name = list(self.desired_positions.keys())\n        cmd_msg.position = list(self.desired_positions.values())\n        self.joint_command_publisher.publish(cmd_msg)\n\n    def publish_posture_status(self):\n        \"\"\"Publish current posture status\"\"\"\n        # WHAT: Publish the current posture state for monitoring\n        # WHY: Other nodes may need to know the robot's current posture\n        status_msg = String()\n        status_msg.data = f\"Current: {self.current_state.value}, Target: {self.target_state.value}\"\n        self.posture_status_publisher.publish(status_msg)\n\ndef main(args=None):\n    \"\"\"Main function to initialize and run the posture controller agent\"\"\"\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n    agent = PostureControllerAgent()\n\n    try:\n        # Start spinning the node to process callbacks\n        # WHAT: This starts the ROS 2 event loop, processing all callbacks\n        # WHY: Without spinning, the node wouldn't execute its timer and subscriber callbacks\n        rclpy.spin(agent)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        # WHAT: This handles the case when the user interrupts the program\n        # WHY: Provides a clean way to stop the agent when needed\n        agent.get_logger().info('Shutting down posture controller agent')\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        agent.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dependencies"}),": ",(0,r.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,r.jsx)(n.code,{children:"sensor_msgs"}),", ",(0,r.jsx)(n.code,{children:"std_msgs"}),", ",(0,r.jsx)(n.code,{children:"geometry_msgs"})]}),"\n",(0,r.jsx)(n.h3,{id:"exercise-7-multi-agent-coordination",children:"Exercise 7: Multi-Agent Coordination"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Difficulty"}),": Advanced"]}),"\n",(0,r.jsx)(n.p,{children:"Implement a coordinator agent that manages multiple specialized agents (balance, walking, arm control) for a humanoid robot. Include proper coordination protocols, conflict resolution, and graceful degradation when agents fail."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Multi-Agent Coordination Implementation\n# WHAT: This code creates a coordinator agent that manages multiple specialized agents for humanoid control\n# WHY: To demonstrate coordination protocols and conflict resolution between specialized agents\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom std_msgs.msg import String, Bool\nfrom geometry_msgs.msg import Twist\nfrom builtin_interfaces.msg import Time\nimport time\nfrom enum import Enum\nfrom typing import Dict, List\nimport threading\nfrom dataclasses import dataclass\n\n@dataclass\nclass AgentInfo:\n    \"\"\"Information about a managed agent\"\"\"\n    name: str\n    status: str\n    last_seen: Time\n    capabilities: List[str]\n    priority: int\n\nclass SystemState(Enum):\n    \"\"\"Overall system states\"\"\"\n    OPERATIONAL = \"operational\"\n    DEGRADED = \"degraded\"\n    EMERGENCY = \"emergency\"\n    SHUTDOWN = \"shutdown\"\n\nclass AgentCoordinator(Node):\n    def __init__(self):\n        super().__init__('agent_coordinator')\n\n        # System state management\n        # WHAT: Track the overall system state\n        # WHY: The coordinator needs to know the overall health of the system\n        self.system_state = SystemState.OPERATIONAL\n        self.last_update_time = self.get_clock().now()\n\n        # Managed agents registry\n        # WHAT: Keep track of all managed agents and their information\n        # WHY: The coordinator needs to monitor all agents it manages\n        self.agents: Dict[str, AgentInfo] = {}\n        self.agent_priorities = {\n            'balance_controller': 1,  # Highest priority\n            'walking_controller': 2,\n            'arm_controller': 3,\n            'head_controller': 4,\n            'navigation_agent': 5   # Lowest priority\n        }\n\n        # Publishers and subscribers\n        # WHAT: Create communication channels for coordination\n        # WHY: Communication is needed for status updates and command distribution\n        self.status_publisher = self.create_publisher(String, '/coordinator_status', 10)\n        self.command_publisher = self.create_publisher(String, '/system_commands', 10)\n        self.emergency_publisher = self.create_publisher(Bool, '/emergency_stop', 10)\n\n        # Subscribers for agent status and system control\n        self.agent_status_subscriber = self.create_subscription(\n            String, '/agent_status', self.agent_status_callback, 10\n        )\n        self.system_control_subscriber = self.create_subscription(\n            String, '/system_control', self.system_control_callback, 10\n        )\n\n        # Timer for coordination logic\n        # WHAT: Create a timer to run coordination logic periodically\n        # WHY: Regular coordination checks are needed to maintain system health\n        self.coordination_timer = self.create_timer(0.5, self.coordination_step)\n\n        # Initialize agent registry\n        self.register_default_agents()\n\n        self.get_logger().info('Agent Coordinator initialized')\n\n    def register_default_agents(self):\n        \"\"\"Register known agents in the system\"\"\"\n        # WHAT: Register the default agents that are expected in the system\n        # WHY: The coordinator needs to know which agents to monitor\n        default_agents = [\n            'balance_controller',\n            'walking_controller',\n            'arm_controller',\n            'head_controller',\n            'navigation_agent'\n        ]\n\n        for agent_name in default_agents:\n            priority = self.agent_priorities.get(agent_name, 10)\n            self.agents[agent_name] = AgentInfo(\n                name=agent_name,\n                status='unknown',\n                last_seen=self.get_clock().now(),\n                capabilities=[],\n                priority=priority\n            )\n            self.get_logger().info(f'Registered agent: {agent_name} (priority: {priority})')\n\n    def agent_status_callback(self, msg: String):\n        \"\"\"Process agent status updates\"\"\"\n        # WHAT: Process status updates from managed agents\n        # WHY: The coordinator needs to know the current status of each agent\n        try:\n            # Parse status message (format: \"agent_name: status: capabilities\")\n            parts = msg.data.split(': ')\n            if len(parts) >= 2:\n                agent_name = parts[0].strip()\n                status = parts[1].strip()\n\n                if agent_name in self.agents:\n                    self.agents[agent_name].status = status\n                    self.agents[agent_name].last_seen = self.get_clock().now()\n\n                    # Extract capabilities if provided\n                    if len(parts) > 2:\n                        capabilities_str = parts[2].strip()\n                        self.agents[agent_name].capabilities = [cap.strip() for cap in capabilities_str.split(',')]\n\n                    self.get_logger().debug(f'Updated status for {agent_name}: {status}')\n                else:\n                    # Register new agent if not in registry\n                    priority = self.agent_priorities.get(agent_name, 10)\n                    self.agents[agent_name] = AgentInfo(\n                        name=agent_name,\n                        status=status,\n                        last_seen=self.get_clock().now(),\n                        capabilities=[],\n                        priority=priority\n                    )\n                    self.get_logger().info(f'Registered new agent: {agent_name}')\n        except Exception as e:\n            self.get_logger().error(f'Error parsing agent status message: {msg.data}, Error: {str(e)}')\n\n    def system_control_callback(self, msg: String):\n        \"\"\"Process system control commands\"\"\"\n        # WHAT: Process commands sent to the coordination system\n        # WHY: External commands may need to affect multiple agents\n        command = msg.data.lower().strip()\n        self.get_logger().info(f'Received system command: {command}')\n\n        if command == 'emergency_stop':\n            self.emergency_procedure()\n        elif command.startswith('activate_'):\n            agent_name = command.replace('activate_', '')\n            self.activate_agent(agent_name)\n        elif command.startswith('deactivate_'):\n            agent_name = command.replace('deactivate_', '')\n            self.deactivate_agent(agent_name)\n        else:\n            self.get_logger().warning(f'Unknown system command: {command}')\n\n    def coordination_step(self):\n        \"\"\"Main coordination logic step\"\"\"\n        # WHAT: Execute the main coordination logic\n        # WHY: Regular coordination checks ensure system health and proper agent operation\n        current_time = self.get_clock().now()\n        timeout_threshold = rclpy.time.Duration(seconds=5.0)\n\n        # Check for timed out agents\n        # WHAT: Detect agents that haven't reported status recently\n        # WHY: Unresponsive agents may need intervention or replacement\n        for agent_name, agent_info in self.agents.items():\n            time_since_seen = current_time - agent_info.last_seen\n            if time_since_seen > timeout_threshold:\n                if agent_info.status != 'error':\n                    self.get_logger().warning(f'Agent {agent_name} appears to be unresponsive')\n                    agent_info.status = 'timeout'\n                    self.system_state = SystemState.DEGRADED\n\n                    # Trigger recovery procedure for the agent\n                    self.trigger_agent_recovery(agent_name)\n\n        # Assess overall system health\n        operational_count = sum(1 for info in self.agents.values() if info.status == 'operational')\n        total_count = len(self.agents)\n\n        if operational_count == 0:\n            self.system_state = SystemState.EMERGENCY\n        elif operational_count < total_count * 0.5:  # Less than 50% operational\n            self.system_state = SystemState.DEGRADED\n        else:\n            self.system_state = SystemState.OPERATIONAL\n\n        # Publish coordinator status\n        status_msg = String()\n        status_msg.data = f\"Coordinator: {self.system_state.value}, {operational_count}/{total_count} agents operational\"\n        self.status_publisher.publish(status_msg)\n\n        self.last_update_time = current_time\n\n    def trigger_agent_recovery(self, agent_name: str):\n        \"\"\"Trigger recovery procedure for a problematic agent\"\"\"\n        # WHAT: Attempt to recover an agent that is not responding\n        # WHY: Automatic recovery helps maintain system stability\n        self.get_logger().info(f'Triggering recovery for agent: {agent_name}')\n\n        # Send recovery command to the agent\n        recovery_cmd = String()\n        recovery_cmd.data = f'{agent_name}: recovery'\n        self.command_publisher.publish(recovery_cmd)\n\n    def emergency_procedure(self):\n        \"\"\"Execute emergency stop procedure\"\"\"\n        # WHAT: Execute the emergency stop procedure for all agents\n        # WHY: Safety is paramount and requires immediate action when needed\n        self.get_logger().warning('Executing emergency stop procedure')\n\n        # Publish emergency stop to all agents\n        emergency_msg = Bool()\n        emergency_msg.data = True\n        self.emergency_publisher.publish(emergency_msg)\n\n        # Send emergency commands to each agent\n        for agent_name in self.agents.keys():\n            emergency_cmd = String()\n            emergency_cmd.data = f'{agent_name}: emergency_stop'\n            self.command_publisher.publish(emergency_cmd)\n\n        self.system_state = SystemState.EMERGENCY\n\n    def activate_agent(self, agent_name: str):\n        \"\"\"Activate a specific agent\"\"\"\n        # WHAT: Send activation command to a specific agent\n        # WHY: Agents may need to be selectively activated or deactivated\n        if agent_name in self.agents:\n            activation_cmd = String()\n            activation_cmd.data = f'{agent_name}: activate'\n            self.command_publisher.publish(activation_cmd)\n            self.get_logger().info(f'Sent activation command to {agent_name}')\n        else:\n            self.get_logger().warning(f'Attempted to activate unknown agent: {agent_name}')\n\n    def deactivate_agent(self, agent_name: str):\n        \"\"\"Deactivate a specific agent\"\"\"\n        # WHAT: Send deactivation command to a specific agent\n        # WHY: Agents may need to be selectively activated or deactivated\n        if agent_name in self.agents:\n            deactivation_cmd = String()\n            deactivation_cmd.data = f'{agent_name}: deactivate'\n            self.command_publisher.publish(deactivation_cmd)\n            self.get_logger().info(f'Sent deactivation command to {agent_name}')\n        else:\n            self.get_logger().warning(f'Attempted to deactivate unknown agent: {agent_name}')\n\ndef main(args=None):\n    \"\"\"Main function to initialize and run the agent coordinator\"\"\"\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n    coordinator = AgentCoordinator()\n\n    try:\n        # Start spinning the node to process callbacks\n        # WHAT: This starts the ROS 2 event loop, processing all callbacks\n        # WHY: Without spinning, the node wouldn't execute its timer and subscriber callbacks\n        rclpy.spin(coordinator)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        # WHAT: This handles the case when the user interrupts the program\n        # WHY: Provides a clean way to stop the coordinator when needed\n        coordinator.get_logger().info('Shutting down agent coordinator')\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        coordinator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dependencies"}),": ",(0,r.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,r.jsx)(n.code,{children:"sensor_msgs"}),", ",(0,r.jsx)(n.code,{children:"std_msgs"}),", ",(0,r.jsx)(n.code,{children:"geometry_msgs"})]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"These exercises cover the implementation of Python agents for humanoid robot control, from basic monitoring agents to complex state machines and multi-agent coordination systems. Each exercise builds on the concepts introduced in the chapter, providing practical implementations with proper error handling and safety considerations."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}}}]);