"use strict";(globalThis.webpackChunkphysical_ai_book_humanoid=globalThis.webpackChunkphysical_ai_book_humanoid||[]).push([[888],{8453(e,n,t){t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},9252(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"examples/ros2-service","title":"ROS 2 Service Example","description":"Complete ROS 2 Service Node with WHAT/WHY Comments","source":"@site/docs/examples/ros2-service.md","sourceDirName":"examples","slug":"/examples/ros2-service","permalink":"/docs/examples/ros2-service","draft":false,"unlisted":false,"editUrl":"https://github.com/Panaversity/physical_ai_book_humanoid/tree/main/docs/examples/ros2-service.md","tags":[],"version":"current","frontMatter":{}}');var s=t(4848),r=t(8453);const a={},o="ROS 2 Service Example",l={},c=[{value:"Complete ROS 2 Service Node with WHAT/WHY Comments",id:"complete-ros-2-service-node-with-whatwhy-comments",level:2},{value:"Service Client Example",id:"service-client-example",level:2},{value:"Dependencies",id:"dependencies",level:2},{value:"How to Run",id:"how-to-run",level:2},{value:"Expected Output",id:"expected-output",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"ros-2-service-example",children:"ROS 2 Service Example"})}),"\n",(0,s.jsx)(n.h2,{id:"complete-ros-2-service-node-with-whatwhy-comments",children:"Complete ROS 2 Service Node with WHAT/WHY Comments"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Example: ROS 2 Service Node for Humanoid Robot Joint Calibration\n# WHAT: This code creates a ROS 2 service that handles joint calibration requests for humanoid robots\n# WHY: To demonstrate the request-response communication pattern in ROS 2, which is useful for calibration and configuration tasks\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile\nfrom example_interfaces.srv import Trigger\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Bool\nimport time\n\nclass JointCalibrationService(Node):\n    def __init__(self):\n        super().__init__('joint_calibration_service')\n\n        # Create service for joint calibration\n        # WHAT: This creates a service that responds to calibration requests\n        # WHY: Calibration is a synchronous operation that requires a definitive result, making services ideal\n        self.srv = self.create_service(\n            Trigger,\n            'calibrate_joints',\n            self.calibrate_joints_callback\n        )\n\n        # Create publisher for calibration status\n        # WHAT: This publishes calibration status updates\n        # WHY: Other nodes need to know when calibration is in progress or completed\n        self.calibration_status_publisher = self.create_publisher(Bool, 'calibration_status', 10)\n\n        # Store current joint states\n        self.current_joint_states = None\n\n        # Create subscriber for joint states\n        # WHAT: This subscribes to joint state messages to access current positions\n        # WHY: Calibration requires knowledge of current joint positions\n        self.joint_state_subscriber = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        self.get_logger().info('Joint Calibration Service initialized')\n\n    def joint_state_callback(self, msg: JointState):\n        \"\"\"Update current joint state\"\"\"\n        # Store the most recent joint state\n        # WHAT: This saves the latest joint state message\n        # WHY: Calibration process needs access to current joint positions\n        self.current_joint_states = msg\n\n    def calibrate_joints_callback(self, request, response):\n        \"\"\"Handle joint calibration requests\"\"\"\n        # Log the calibration request\n        # WHAT: This logs that a calibration request has been received\n        # WHY: Logging helps with debugging and monitoring system behavior\n        self.get_logger().info('Received joint calibration request')\n\n        # Publish calibration status (in progress)\n        # WHAT: This publishes a status message indicating calibration has started\n        # WHY: Other nodes need to know the robot is busy with calibration\n        status_msg = Bool()\n        status_msg.data = True\n        self.calibration_status_publisher.publish(status_msg)\n\n        # Simulate the calibration process\n        # WHAT: This simulates the actual calibration procedure\n        # WHY: Real calibration would involve moving joints to known positions and setting encoders\n        try:\n            # Check if we have joint state data\n            if self.current_joint_states is None:\n                response.success = False\n                response.message = 'No joint state data available for calibration'\n                self.get_logger().error(response.message)\n                return response\n\n            # Simulate calibration steps\n            # WHAT: This simulates the process of calibrating each joint\n            # WHY: Each joint needs to be moved to a known reference position during calibration\n            for i, joint_name in enumerate(self.current_joint_states.name):\n                self.get_logger().info(f'Calibrating joint: {joint_name} ({i+1}/{len(self.current_joint_states.name)})')\n\n                # Simulate time needed for each joint calibration\n                time.sleep(0.2)  # Simulate actual calibration time\n\n            # Simulate final calibration steps\n            # WHAT: This simulates final verification steps after all joints are calibrated\n            # WHY: Verification ensures the calibration was successful\n            time.sleep(0.5)\n\n            # Set response values for successful calibration\n            # WHAT: This sets the response to indicate success\n            # WHY: The service client needs to know if the operation was successful\n            response.success = True\n            response.message = f'Successfully calibrated {len(self.current_joint_states.name)} joints'\n            self.get_logger().info(response.message)\n\n        except Exception as e:\n            # Handle any errors during calibration\n            # WHAT: This catches and handles any exceptions during the calibration process\n            # WHY: Error handling ensures the service doesn't crash and provides useful feedback\n            response.success = False\n            response.message = f'Calibration failed: {str(e)}'\n            self.get_logger().error(response.message)\n\n        finally:\n            # Publish calibration status (completed)\n            # WHAT: This publishes a status message indicating calibration has completed\n            # WHY: Other nodes need to know when the robot is no longer busy with calibration\n            status_msg = Bool()\n            status_msg.data = False\n            self.calibration_status_publisher.publish(status_msg)\n\n        return response\n\ndef main(args=None):\n    \"\"\"Main function to initialize and run the ROS 2 service node\"\"\"\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n\n    # Create an instance of the JointCalibrationService node\n    # WHAT: This creates the service node instance\n    # WHY: The node contains all the logic for handling calibration requests\n    calibration_service = JointCalibrationService()\n\n    try:\n        # Start spinning the node to process service requests\n        # WHAT: This starts the ROS 2 event loop, processing incoming service requests\n        # WHY: Without spinning, the node wouldn't execute its service callback functions\n        rclpy.spin(calibration_service)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        pass\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        calibration_service.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"service-client-example",children:"Service Client Example"}),"\n",(0,s.jsx)(n.p,{children:"Here's how to call the service from a client:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Example: ROS 2 Service Client for Joint Calibration\n# WHAT: This code creates a client that calls the joint calibration service\n# WHY: To demonstrate how to call a ROS 2 service from another node\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import Trigger\n\nclass CalibrationClient(Node):\n    def __init__(self):\n        super().__init__('calibration_client')\n\n        # Create a client for the calibration service\n        # WHAT: This creates a service client to call the calibration service\n        # WHY: The client needs to be able to request calibration from the service\n        self.cli = self.create_client(Trigger, 'calibrate_joints')\n\n        # Wait for the service to be available\n        # WHAT: This waits until the service is ready to accept requests\n        # WHY: Trying to call a service before it's available would result in an error\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Calibration service not available, waiting again...')\n\n        self.req = Trigger.Request()\n\n    def send_request(self):\n        \"\"\"Send a calibration request to the service\"\"\"\n        # Call the service asynchronously\n        # WHAT: This sends an asynchronous request to the calibration service\n        # WHY: Asynchronous calls don't block the node while waiting for a response\n        self.future = self.cli.call_async(self.req)\n        return self.future\n\ndef main(args=None):\n    \"\"\"Main function to run the service client\"\"\"\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n\n    # Create the client node\n    calibration_client = CalibrationClient()\n\n    # Send the calibration request\n    # WHAT: This sends a request to the calibration service\n    # WHY: Initiates the calibration process\n    future = calibration_client.send_request()\n\n    try:\n        # Wait for the response\n        # WHAT: This waits for the service to complete and return a response\n        # WHY: The client needs to know the result of the calibration operation\n        rclpy.spin_until_future_complete(calibration_client, future)\n\n        # Process the response\n        # WHAT: This processes the response from the calibration service\n        # WHY: The client needs to know if the calibration was successful\n        if future.result() is not None:\n            response = future.result()\n            if response.success:\n                calibration_client.get_logger().info(f'Calibration successful: {response.message}')\n            else:\n                calibration_client.get_logger().error(f'Calibration failed: {response.message}')\n        else:\n            calibration_client.get_logger().error('Failed to get calibration response')\n\n    except KeyboardInterrupt:\n        calibration_client.get_logger().info('Calibration client interrupted')\n    finally:\n        calibration_client.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"example_interfaces"})," - Standard ROS 2 service interfaces"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sensor_msgs"})," - Sensor-related message types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std_msgs"})," - Standard ROS 2 message types"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"how-to-run",children:"How to Run"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Terminal 1: Run the service\nsource /opt/ros/kilted/setup.bash\npython3 joint_calibration_service.py\n\n# Terminal 2: Run the client to call the service\nsource /opt/ros/kilted/setup.bash\npython3 calibration_client.py\n"})}),"\n",(0,s.jsx)(n.h2,{id:"expected-output",children:"Expected Output"}),"\n",(0,s.jsx)(n.p,{children:"The service will log when it receives calibration requests and simulate the calibration process. The client will log whether the calibration was successful or not."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);