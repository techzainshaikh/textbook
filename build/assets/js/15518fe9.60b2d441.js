"use strict";(globalThis.webpackChunkphysical_ai_book_humanoid=globalThis.webpackChunkphysical_ai_book_humanoid||[]).push([[103],{8453(e,t,n){n.d(t,{R:()=>s,x:()=>a});var r=n(6540);const i={},o=r.createContext(i);function s(e){const t=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:t},e.children)}},8498(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-1-ros2/chapter-4-exercises","title":"Chapter 4 - Exercises","description":"Exercises for ROS 2 control architecture in humanoid robotics","source":"@site/docs/module-1-ros2/chapter-4-exercises.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-4-exercises","permalink":"/docs/module-1-ros2/chapter-4-exercises","draft":false,"unlisted":false,"editUrl":"https://github.com/Panaversity/physical_ai_book_humanoid/tree/main/docs/module-1-ros2/chapter-4-exercises.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9,"title":"Chapter 4 - Exercises","description":"Exercises for ROS 2 control architecture in humanoid robotics","keywords":["control","architecture","ros2","exercises","humanoid","robotics"]},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4 - ROS 2 Control Architecture","permalink":"/docs/module-1-ros2/chapter-4-control-architecture"},"next":{"title":"Chapter 5 - Summary and Exercises","permalink":"/docs/module-1-ros2/chapter-5-summary-exercises"}}');var i=n(4848),o=n(8453);const s={sidebar_position:9,title:"Chapter 4 - Exercises",description:"Exercises for ROS 2 control architecture in humanoid robotics",keywords:["control","architecture","ros2","exercises","humanoid","robotics"]},a="Chapter 4 - Exercises",l={},c=[{value:"Conceptual Exercises",id:"conceptual-exercises",level:2},{value:"Exercise 1: Control Architecture Design",id:"exercise-1-control-architecture-design",level:3},{value:"Exercise 2: Safety System Design",id:"exercise-2-safety-system-design",level:3},{value:"Logical Exercises",id:"logical-exercises",level:2},{value:"Exercise 3: Control Priority Logic",id:"exercise-3-control-priority-logic",level:3},{value:"Exercise 4: Fault Detection Logic",id:"exercise-4-fault-detection-logic",level:3},{value:"Implementation Exercises",id:"implementation-exercises",level:2},{value:"Exercise 5: PID Controller Implementation",id:"exercise-5-pid-controller-implementation",level:3},{value:"Exercise 6: Joint Trajectory Controller",id:"exercise-6-joint-trajectory-controller",level:3},{value:"Exercise 7: Safety Monitor Implementation",id:"exercise-7-safety-monitor-implementation",level:3},{value:"Summary",id:"summary",level:2}];function m(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"chapter-4---exercises",children:"Chapter 4 - Exercises"})}),"\n",(0,i.jsx)(t.h2,{id:"conceptual-exercises",children:"Conceptual Exercises"}),"\n",(0,i.jsx)(t.h3,{id:"exercise-1-control-architecture-design",children:"Exercise 1: Control Architecture Design"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Difficulty"}),": Intermediate"]}),"\n",(0,i.jsx)(t.p,{children:"Design a control architecture for a humanoid robot that can walk, maintain balance, and manipulate objects simultaneously. Identify the different control layers needed, their interactions, and potential conflicts. Explain how you would prioritize these tasks and handle conflicts between them."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Solution"}),":\nA hierarchical control architecture would include:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"High-level task planner (coordinates walking, balancing, and manipulation)"}),"\n",(0,i.jsx)(t.li,{children:"Mid-level motion generators (creates trajectories for each task)"}),"\n",(0,i.jsx)(t.li,{children:"Low-level joint controllers (executes precise joint commands)\nConflicts would be resolved through priority-based allocation of DOFs and coordinated motion planning."}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"exercise-2-safety-system-design",children:"Exercise 2: Safety System Design"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Difficulty"}),": Advanced"]}),"\n",(0,i.jsx)(t.p,{children:"Design a comprehensive safety system for humanoid robot control that includes emergency stops, error detection, recovery procedures, and safe states. Consider both hardware and software failures, and explain how the system would respond to each type of failure."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Solution"}),":\nSafety system would include:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Hardware-level safety (emergency stops, current limits)"}),"\n",(0,i.jsx)(t.li,{children:"Software-level monitoring (position, velocity, temperature limits)"}),"\n",(0,i.jsx)(t.li,{children:"Recovery procedures (graceful degradation, safe poses)"}),"\n",(0,i.jsx)(t.li,{children:"Fail-safe states (emergency stop, passive compliance)"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"logical-exercises",children:"Logical Exercises"}),"\n",(0,i.jsx)(t.h3,{id:"exercise-3-control-priority-logic",children:"Exercise 3: Control Priority Logic"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Difficulty"}),": Intermediate"]}),"\n",(0,i.jsx)(t.p,{children:"Design a logical system for determining control priority when multiple controllers want to command the same joint. Consider factors such as safety, task urgency, and coordination requirements. Create a decision tree or algorithm for resolving conflicts."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Solution"}),":\nPriority algorithm:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Safety-related commands (highest priority)"}),"\n",(0,i.jsx)(t.li,{children:"Balance maintenance commands"}),"\n",(0,i.jsx)(t.li,{children:"Task-level commands (based on urgency)"}),"\n",(0,i.jsx)(t.li,{children:"Posture maintenance (lowest priority)\nCommands would be blended based on priority and task requirements."}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"exercise-4-fault-detection-logic",children:"Exercise 4: Fault Detection Logic"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Difficulty"}),": Advanced"]}),"\n",(0,i.jsx)(t.p,{children:"Create a logical framework for detecting faults in humanoid robot control systems. Define the conditions that constitute a fault, the detection mechanisms, and the classification system for different types of faults. Consider both abrupt and gradual fault onset."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Solution"}),":\nFault detection framework:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Abrupt faults: sudden position/velocity errors, communication timeouts"}),"\n",(0,i.jsx)(t.li,{children:"Gradual faults: increasing tracking errors, parameter drift"}),"\n",(0,i.jsx)(t.li,{children:"Detection: statistical analysis, threshold comparisons, model-based prediction"}),"\n",(0,i.jsx)(t.li,{children:"Classification: hardware, software, communication, environmental"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"implementation-exercises",children:"Implementation Exercises"}),"\n",(0,i.jsx)(t.h3,{id:"exercise-5-pid-controller-implementation",children:"Exercise 5: PID Controller Implementation"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Difficulty"}),": Beginner"]}),"\n",(0,i.jsx)(t.p,{children:"Implement a PID controller for a single joint with configurable gains and safety limits. Include anti-windup protection, derivative filtering, and proper initialization. Test the controller with different input profiles and verify its behavior."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'# PID Controller Implementation\n# WHAT: This code implements a PID controller for a single joint with safety limits and anti-windup\n# WHY: To demonstrate fundamental PID control concepts for humanoid robot joints\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64\nimport time\n\nclass JointPIDController(Node):\n    def __init__(self):\n        super().__init__(\'joint_pid_controller\')\n\n        # Controller parameters\n        # WHAT: Define PID gains and safety limits for the controller\n        # WHY: These parameters determine the controller\'s response and safety behavior\n        self.kp = 100.0    # Proportional gain\n        self.ki = 0.1      # Integral gain\n        self.kd = 10.0     # Derivative gain\n        self.max_effort = 100.0  # Maximum effort limit (N-m or appropriate units)\n        self.max_integral = 10.0  # Maximum integral term to prevent windup\n\n        # Controller state variables\n        # WHAT: Store the current state of the PID controller\n        # WHY: These variables are needed for computing the control output\n        self.setpoint = 0.0\n        self.current_position = 0.0\n        self.current_velocity = 0.0\n        self.previous_error = 0.0\n        self.integral_error = 0.0\n        self.previous_time = self.get_clock().now()\n\n        # Publishers and subscribers\n        # WHAT: Create publisher for effort commands and subscriber for joint state feedback\n        # WHY: Communication is needed for control and feedback\n        self.effort_publisher = self.create_publisher(Float64, \'/joint_effort_command\', 10)\n        self.joint_state_subscriber = self.create_subscription(\n            JointState, \'/joint_state_feedback\', self.joint_state_callback, 10\n        )\n\n        # Command subscriber for changing setpoints\n        self.setpoint_subscriber = self.create_subscription(\n            Float64, \'/joint_setpoint\', self.setpoint_callback, 10\n        )\n\n        # Control timer\n        # WHAT: Create a timer to execute the control loop at regular intervals\n        # WHY: PID control requires consistent timing for proper derivative calculation\n        self.control_timer = self.create_timer(0.01, self.control_loop)  # 100 Hz\n\n        self.get_logger().info(\'Joint PID Controller initialized\')\n\n    def joint_state_callback(self, msg: JointState):\n        """Update current joint state from feedback"""\n        # WHAT: Process incoming joint state messages to update current position and velocity\n        # WHY: Feedback is needed to compute control errors\n        if len(msg.position) > 0:\n            self.current_position = msg.position[0]\n        if len(msg.velocity) > 0:\n            self.current_velocity = msg.velocity[0]\n\n    def setpoint_callback(self, msg: Float64):\n        """Update the desired setpoint"""\n        # WHAT: Process incoming setpoint commands to update the desired position\n        # WHY: The controller needs to know the target position to compute errors\n        self.setpoint = msg.data\n        self.get_logger().info(f\'New setpoint received: {self.setpoint}\')\n\n    def control_loop(self):\n        """Execute the PID control algorithm"""\n        # WHAT: This is the main PID control loop that runs at 100Hz\n        # WHY: Real-time control requires consistent execution at regular intervals\n        current_time = self.get_clock().now()\n        dt = (current_time - self.previous_time).nanoseconds / 1e9\n        self.previous_time = current_time\n\n        if dt <= 0:  # Avoid division by zero\n            return\n\n        # Calculate error\n        # WHAT: Compute the difference between desired and actual position\n        # WHY: Error is the fundamental input to the PID control algorithm\n        error = self.setpoint - self.current_position\n\n        # Update integral term with anti-windup protection\n        # WHAT: Accumulate error over time for the integral component\n        # WHY: The integral term helps eliminate steady-state error\n        self.integral_error += error * dt\n\n        # Anti-windup: limit the integral term to prevent excessive accumulation\n        # WHAT: Apply limits to the integral accumulator to prevent windup\n        # WHY: Windup occurs when the integral term grows too large during saturation\n        self.integral_error = max(-self.max_integral, min(self.max_integral, self.integral_error))\n\n        # Calculate derivative term (using feedback to avoid derivative kick)\n        # WHAT: Compute the rate of change of error for the derivative component\n        # WHY: The derivative term provides damping to reduce oscillation\n        derivative = -self.current_velocity  # Using negative velocity to avoid setpoint derivative\n\n        # Calculate PID output\n        # WHAT: Combine the three PID terms to get the control output\n        # WHY: The PID formula provides balanced control with proportional, integral, and derivative action\n        p_term = self.kp * error\n        i_term = self.ki * self.integral_error\n        d_term = self.kd * derivative\n\n        effort_output = p_term + i_term + d_term\n\n        # Apply effort limits\n        # WHAT: Limit the output to safe values to protect the joint\n        # WHY: Excessive effort can damage the motor or transmission\n        effort_output = max(-self.max_effort, min(self.max_effort, effort_output))\n\n        # Publish effort command\n        # WHAT: Send the computed effort command to the joint\n        # WHY: The command needs to be transmitted to the actuator for execution\n        effort_msg = Float64()\n        effort_msg.data = effort_output\n        self.effort_publisher.publish(effort_msg)\n\n        # Store current error for next derivative calculation\n        self.previous_error = error\n\n        # Log control information for debugging\n        self.get_logger().debug(f\'Error: {error:.3f}, P: {p_term:.3f}, I: {i_term:.3f}, D: {d_term:.3f}, Effort: {effort_output:.3f}\')\n\ndef main(args=None):\n    """Main function to initialize and run the PID controller"""\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n    controller = JointPIDController()\n\n    try:\n        # Start spinning the node to process callbacks\n        # WHAT: This starts the ROS 2 event loop, processing all callbacks\n        # WHY: Without spinning, the node wouldn\'t execute its timer and subscriber callbacks\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        # WHAT: This handles the case when the user interrupts the program\n        # WHY: Provides a clean way to stop the controller when needed\n        controller.get_logger().info(\'Shutting down PID controller\')\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Dependencies"}),": ",(0,i.jsx)(t.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,i.jsx)(t.code,{children:"sensor_msgs"}),", ",(0,i.jsx)(t.code,{children:"std_msgs"})]}),"\n",(0,i.jsx)(t.h3,{id:"exercise-6-joint-trajectory-controller",children:"Exercise 6: Joint Trajectory Controller"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Difficulty"}),": Intermediate"]}),"\n",(0,i.jsx)(t.p,{children:"Implement a joint trajectory controller that interpolates between waypoints and sends smooth commands to the low-level joint controllers. Include proper synchronization between multiple joints and handle trajectory abort conditions."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'# Joint Trajectory Controller Implementation\n# WHAT: This code implements a trajectory controller that interpolates between waypoints\n# WHY: To demonstrate smooth motion control for humanoid robot joints\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom control_msgs.msg import FollowJointTrajectoryAction, FollowJointTrajectoryFeedback, FollowJointTrajectoryResult\nfrom std_msgs.msg import Float64MultiArray\nfrom builtin_interfaces.msg import Duration\nimport time\nimport math\nfrom enum import Enum\nfrom typing import List, Dict\n\nclass TrajectoryState(Enum):\n    """Enumeration of trajectory execution states"""\n    IDLE = "idle"\n    EXECUTING = "executing"\n    PAUSED = "paused"\n    ABORTED = "aborted"\n    COMPLETED = "completed"\n\nclass JointTrajectoryController(Node):\n    def __init__(self):\n        super().__init__(\'joint_trajectory_controller\')\n\n        # Controller parameters\n        # WHAT: Define parameters for trajectory execution\n        # WHY: These parameters control the smoothness and safety of motion\n        self.joint_names = [\n            \'left_hip\', \'left_knee\', \'left_ankle\',\n            \'right_hip\', \'right_knee\', \'right_ankle\',\n            \'left_shoulder\', \'left_elbow\', \'right_shoulder\', \'right_elbow\'\n        ]\n        self.default_max_velocity = 2.0  # rad/s\n        self.default_max_acceleration = 5.0  # rad/s^2\n\n        # Trajectory execution state\n        # WHAT: Track the current state of trajectory execution\n        # WHY: State management is essential for proper trajectory control\n        self.state = TrajectoryState.IDLE\n        self.current_trajectory = None\n        self.current_point_index = 0\n        self.trajectory_start_time = None\n        self.current_positions = {name: 0.0 for name in self.joint_names}\n        self.current_velocities = {name: 0.0 for name in self.joint_names}\n\n        # Publishers and subscribers\n        # WHAT: Create communication channels for trajectory control\n        # WHY: Communication is needed for receiving trajectories and sending commands\n        self.joint_command_publisher = self.create_publisher(Float64MultiArray, \'/joint_commands\', 10)\n        self.joint_state_subscriber = self.create_subscription(\n            JointState, \'/joint_states\', self.joint_state_callback, 10\n        )\n        self.trajectory_subscriber = self.create_subscription(\n            JointTrajectory, \'/joint_trajectory\', self.trajectory_callback, 10\n        )\n\n        # Timer for trajectory execution\n        # WHAT: Create a timer to execute trajectory interpolation at regular intervals\n        # WHY: Smooth trajectory execution requires consistent timing\n        self.execution_timer = self.create_timer(0.01, self.trajectory_execution_loop)  # 100 Hz\n\n        self.get_logger().info(\'Joint Trajectory Controller initialized\')\n\n    def joint_state_callback(self, msg: JointState):\n        """Update current joint states from feedback"""\n        # WHAT: Process incoming joint state messages to update current positions and velocities\n        # WHY: Feedback is needed to track actual joint positions during trajectory execution\n        for i, name in enumerate(msg.name):\n            if name in self.current_positions:\n                if i < len(msg.position):\n                    self.current_positions[name] = msg.position[i]\n                if i < len(msg.velocity):\n                    self.current_velocities[name] = msg.velocity[i]\n\n    def trajectory_callback(self, msg: JointTrajectory):\n        """Handle incoming trajectory commands"""\n        # WHAT: Process incoming trajectory commands and begin execution\n        # WHY: The controller needs to know the desired trajectory to follow\n        if len(msg.points) == 0:\n            self.get_logger().warning(\'Received trajectory with no points\')\n            return\n\n        # Validate trajectory joint names\n        # WHAT: Verify that the trajectory contains the expected joint names\n        # WHY: Invalid joint names would cause the controller to fail\n        if msg.joint_names != self.joint_names:\n            self.get_logger().error(f\'Trajectory joint names mismatch. Expected: {self.joint_names}, Got: {msg.joint_names}\')\n            return\n\n        # Store trajectory and start execution\n        # WHAT: Store the received trajectory and transition to executing state\n        # WHY: The controller needs to execute the received trajectory\n        self.current_trajectory = msg\n        self.current_point_index = 0\n        self.trajectory_start_time = self.get_clock().now()\n        self.state = TrajectoryState.EXECUTING\n\n        self.get_logger().info(f\'Received trajectory with {len(msg.points)} points for joints: {msg.joint_names}\')\n\n    def trajectory_execution_loop(self):\n        """Execute trajectory interpolation and command generation"""\n        # WHAT: This is the main trajectory execution loop that runs at 100Hz\n        # WHY: Smooth trajectory execution requires consistent timing for interpolation\n        if self.state != TrajectoryState.EXECUTING or self.current_trajectory is None:\n            return\n\n        # Check if trajectory is complete\n        # WHAT: Verify if all trajectory points have been executed\n        # WHY: Execution should stop when the trajectory is complete\n        if self.current_point_index >= len(self.current_trajectory.points):\n            self.state = TrajectoryState.COMPLETED\n            self.get_logger().info(\'Trajectory execution completed\')\n            return\n\n        # Get current trajectory point\n        # WHAT: Retrieve the current point in the trajectory\n        # WHY: The controller needs to interpolate between current and next points\n        current_point = self.current_trajectory.points[self.current_point_index]\n\n        # Calculate elapsed time since trajectory start\n        # WHAT: Determine how much time has passed since the trajectory began\n        # WHY: Time is needed for interpolation between trajectory points\n        elapsed_time = (self.get_clock().now() - self.trajectory_start_time).nanoseconds / 1e9\n\n        # Check if we need to advance to the next point\n        # WHAT: Determine if enough time has passed to move to the next trajectory point\n        # WHY: Trajectories consist of multiple points to be executed over time\n        if elapsed_time >= current_point.time_from_start.sec + current_point.time_from_start.nanosec / 1e9:\n            self.current_point_index += 1\n            if self.current_point_index < len(self.current_trajectory.points):\n                # Move to the next point\n                next_point = self.current_trajectory.points[self.current_point_index]\n                self.trajectory_start_time = self.get_clock().now()\n                self.get_logger().info(f\'Moved to trajectory point {self.current_point_index}\')\n            return\n\n        # Calculate interpolation between current and previous points\n        # WHAT: Interpolate joint positions between trajectory points\n        # WHY: Smooth motion requires interpolation between discrete trajectory points\n        if self.current_point_index > 0:\n            prev_point = self.current_trajectory.points[self.current_point_index - 1]\n            next_point = current_point\n\n            # Calculate interpolation factor\n            prev_time = prev_point.time_from_start.sec + prev_point.time_from_start.nanosec / 1e9\n            next_time = next_point.time_from_start.sec + next_point.time_from_start.nanosec / 1e9\n            current_elapsed = elapsed_time\n\n            # Ensure we don\'t go beyond the next point\'s time\n            current_elapsed = min(current_elapsed, next_time)\n\n            if next_time > prev_time:\n                t = (current_elapsed - prev_time) / (next_time - prev_time)\n                t = max(0.0, min(1.0, t))  # Clamp to [0, 1]\n\n                # Linear interpolation between points\n                # WHAT: Perform linear interpolation between trajectory points\n                # WHY: Linear interpolation provides smooth motion between discrete points\n                interpolated_positions = []\n                for i in range(len(prev_point.positions)):\n                    pos = prev_point.positions[i] + t * (next_point.positions[i] - prev_point.positions[i])\n                    interpolated_positions.append(pos)\n\n                # Publish interpolated commands\n                # WHAT: Send the interpolated joint positions as commands\n                # WHY: Commands need to be sent to the actuators for execution\n                command_msg = Float64MultiArray()\n                command_msg.data = interpolated_positions\n                self.joint_command_publisher.publish(command_msg)\n\n                # Log trajectory progress\n                self.get_logger().debug(f\'Trajectory progress: {t:.2f}, Positions: {interpolated_positions}\')\n            else:\n                # If times are equal, use the next point directly\n                command_msg = Float64MultiArray()\n                command_msg.data = next_point.positions\n                self.joint_command_publisher.publish(command_msg)\n        else:\n            # For the first point, publish directly\n            command_msg = Float64MultiArray()\n            command_msg.data = current_point.positions\n            self.joint_command_publisher.publish(command_msg)\n\n    def abort_trajectory(self):\n        """Abort current trajectory execution"""\n        # WHAT: Stop the current trajectory execution and transition to aborted state\n        # WHY: Sometimes trajectories need to be stopped due to safety or other conditions\n        if self.state == TrajectoryState.EXECUTING:\n            self.state = TrajectoryState.ABORTED\n            self.get_logger().warning(\'Trajectory execution aborted\')\n\n    def pause_trajectory(self):\n        """Pause current trajectory execution"""\n        # WHAT: Pause the current trajectory execution\n        # WHY: Trajectories might need to be paused temporarily\n        if self.state == TrajectoryState.EXECUTING:\n            self.state = TrajectoryState.PAUSED\n            self.get_logger().info(\'Trajectory execution paused\')\n\n    def resume_trajectory(self):\n        """Resume paused trajectory execution"""\n        # WHAT: Resume a paused trajectory execution\n        # WHY: Paused trajectories can be resumed after the pause reason is resolved\n        if self.state == TrajectoryState.PAUSED:\n            self.state = TrajectoryState.EXECUTING\n            self.get_logger().info(\'Trajectory execution resumed\')\n\ndef main(args=None):\n    """Main function to initialize and run the trajectory controller"""\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n    controller = JointTrajectoryController()\n\n    try:\n        # Start spinning the node to process callbacks\n        # WHAT: This starts the ROS 2 event loop, processing all callbacks\n        # WHY: Without spinning, the node wouldn\'t execute its timer and subscriber callbacks\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        # WHAT: This handles the case when the user interrupts the program\n        # WHY: Provides a clean way to stop the controller when needed\n        controller.get_logger().info(\'Shutting down trajectory controller\')\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Dependencies"}),": ",(0,i.jsx)(t.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,i.jsx)(t.code,{children:"sensor_msgs"}),", ",(0,i.jsx)(t.code,{children:"trajectory_msgs"}),", ",(0,i.jsx)(t.code,{children:"control_msgs"}),", ",(0,i.jsx)(t.code,{children:"std_msgs"})]}),"\n",(0,i.jsx)(t.h3,{id:"exercise-7-safety-monitor-implementation",children:"Exercise 7: Safety Monitor Implementation"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Difficulty"}),": Advanced"]}),"\n",(0,i.jsx)(t.p,{children:"Implement a safety monitor that continuously checks joint limits, velocity limits, temperature limits, and position tracking errors. The monitor should trigger appropriate responses when limits are exceeded, including reducing gains, limiting commands, or initiating emergency stops."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Safety Monitor Implementation\n# WHAT: This code implements a safety monitor for humanoid robot control systems\n# WHY: To ensure safe operation with continuous monitoring and emergency procedures\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Temperature\nfrom std_msgs.msg import Bool, String, Float64\nfrom builtin_interfaces.msg import Time\nimport time\nfrom enum import Enum\nfrom typing import Dict, List\n\nclass SafetyLevel(Enum):\n    \"\"\"Enumeration of safety levels\"\"\"\n    NORMAL = \"normal\"\n    WARNING = \"warning\"\n    ERROR = \"error\"\n    EMERGENCY = \"emergency\"\n\nclass SafetyMonitor(Node):\n    def __init__(self):\n        super().__init__('safety_monitor')\n\n        # Safety parameters\n        # WHAT: Define safety limits and thresholds for monitoring\n        # WHY: Safety parameters determine when the system should take protective actions\n        self.position_limits = {\n            'hip': (math.radians(-90), math.radians(90)),      # Radians\n            'knee': (math.radians(-180), math.radians(0)),     # Radians\n            'ankle': (math.radians(-30), math.radians(30)),    # Radians\n            'shoulder': (math.radians(-120), math.radians(120)), # Radians\n            'elbow': (math.radians(-160), math.radians(0))     # Radians\n        }\n\n        self.velocity_limits = {\n            'hip': math.radians(120),      # rad/s\n            'knee': math.radians(120),     # rad/s\n            'ankle': math.radians(180),    # rad/s\n            'shoulder': math.radians(120), # rad/s\n            'elbow': math.radians(180)     # rad/s\n        }\n\n        self.temperature_limits = {\n            'hip': 70.0,      # Celsius\n            'knee': 70.0,\n            'ankle': 70.0,\n            'shoulder': 70.0,\n            'elbow': 70.0\n        }\n\n        self.error_threshold = math.radians(10)  # Maximum tracking error (radians)\n\n        # Joint state tracking\n        # WHAT: Store current and previous joint states for monitoring\n        # WHY: Monitoring requires comparing current states to limits and previous states\n        self.joint_positions = {}\n        self.joint_velocities = {}\n        self.joint_efforts = {}\n        self.joint_temperatures = {}\n        self.previous_positions = {}\n        self.joint_desired_positions = {}\n\n        # System state\n        # WHAT: Track the overall safety state of the system\n        # WHY: The safety state determines what actions should be taken\n        self.safety_level = SafetyLevel.NORMAL\n        self.emergency_active = False\n        self.last_emergency_time = None\n\n        # Publishers and subscribers\n        # WHAT: Create communication channels for safety monitoring\n        # WHY: Communication is needed to receive data and send safety commands\n        self.emergency_publisher = self.create_publisher(Bool, '/emergency_stop', 10)\n        self.safety_status_publisher = self.create_publisher(String, '/safety_status', 10)\n        self.error_publisher = self.create_publisher(String, '/error_report', 10)\n        self.gain_reduction_publisher = self.create_publisher(Float64, '/gain_reduction', 10)\n\n        # Subscribers for monitoring\n        self.joint_state_subscriber = self.create_subscription(\n            JointState, '/joint_states', self.joint_state_callback, 10\n        )\n\n        self.joint_temp_subscriber = self.create_subscription(\n            Temperature, '/joint_temperatures', self.joint_temp_callback, 10\n        )\n\n        self.desired_state_subscriber = self.create_subscription(\n            JointState, '/joint_desired_states', self.desired_state_callback, 10\n        )\n\n        # Safety monitoring timer\n        # WHAT: Create a timer to execute safety checks at regular intervals\n        # WHY: Continuous monitoring requires consistent timing\n        self.safety_timer = self.create_timer(0.1, self.safety_check)  # 10 Hz\n\n        # Initialize joint names\n        self.joint_names = [\n            'left_hip', 'left_knee', 'left_ankle',\n            'right_hip', 'right_knee', 'right_ankle',\n            'left_shoulder', 'left_elbow', 'right_shoulder', 'right_elbow'\n        ]\n\n        # Initialize joint dictionaries\n        for name in self.joint_names:\n            self.joint_positions[name] = 0.0\n            self.joint_velocities[name] = 0.0\n            self.joint_efforts[name] = 0.0\n            self.joint_temperatures[name] = 25.0  # Default temperature\n            self.previous_positions[name] = 0.0\n            self.joint_desired_positions[name] = 0.0\n\n        self.get_logger().info('Safety Monitor initialized')\n\n    def joint_state_callback(self, msg: JointState):\n        \"\"\"Update joint states from sensor feedback\"\"\"\n        # WHAT: Process incoming joint state messages to update current joint states\n        # WHY: The safety monitor needs current joint states to perform checks\n        for i, name in enumerate(msg.name):\n            if name in self.joint_positions:\n                if i < len(msg.position):\n                    self.previous_positions[name] = self.joint_positions[name]\n                    self.joint_positions[name] = msg.position[i]\n                if i < len(msg.velocity):\n                    self.joint_velocities[name] = msg.velocity[i]\n                if i < len(msg.effort):\n                    self.joint_efforts[name] = msg.effort[i]\n\n    def joint_temp_callback(self, msg: Temperature):\n        \"\"\"Update joint temperature information\"\"\"\n        # WHAT: Process incoming temperature messages to update joint temperatures\n        # WHY: Temperature monitoring is important for preventing motor damage\n        # This would typically come from a temperature topic, but for simulation\n        # we'll use the joint name and effort to estimate temperature\n        for joint_name, effort in self.joint_efforts.items():\n            # Estimate temperature based on effort (simplified model)\n            base_temp = 25.0\n            temp_rise = abs(effort) * 0.1\n            self.joint_temperatures[joint_name] = base_temp + temp_rise\n\n    def desired_state_callback(self, msg: JointState):\n        \"\"\"Update desired joint positions for error calculation\"\"\"\n        # WHAT: Process incoming desired state messages to update target positions\n        # WHY: Tracking error calculation requires knowledge of desired positions\n        for i, name in enumerate(msg.name):\n            if name in self.joint_desired_positions and i < len(msg.position):\n                self.joint_desired_positions[name] = msg.position[i]\n\n    def check_position_limits(self) -> List[str]:\n        \"\"\"Check joint position limits\"\"\"\n        # WHAT: Verify that joint positions are within safe limits\n        # WHY: Exceeding position limits can cause mechanical damage\n        errors = []\n\n        for joint_name, position in self.joint_positions.items():\n            joint_type = self.get_joint_type(joint_name)\n            limits = self.position_limits.get(joint_type, (-float('inf'), float('inf')))\n\n            if position < limits[0] or position > limits[1]:\n                errors.append(f\"Joint {joint_name} position limit exceeded: {math.degrees(position):.2f}\xb0, limits: [{math.degrees(limits[0]):.2f}\xb0, {math.degrees(limits[1]):.2f}\xb0]\")\n\n        return errors\n\n    def check_velocity_limits(self) -> List[str]:\n        \"\"\"Check joint velocity limits\"\"\"\n        # WHAT: Verify that joint velocities are within safe limits\n        # WHY: Exceeding velocity limits can cause mechanical stress and damage\n        errors = []\n\n        for joint_name, velocity in self.joint_velocities.items():\n            joint_type = self.get_joint_type(joint_name)\n            max_velocity = self.velocity_limits.get(joint_type, float('inf'))\n\n            if abs(velocity) > max_velocity:\n                errors.append(f\"Joint {joint_name} velocity limit exceeded: {math.degrees(velocity):.2f}\xb0/s, limit: {math.degrees(max_velocity):.2f}\xb0/s\")\n\n        return errors\n\n    def check_temperature_limits(self) -> List[str]:\n        \"\"\"Check joint temperature limits\"\"\"\n        # WHAT: Verify that joint temperatures are within safe limits\n        # WHY: Exceeding temperature limits can damage motors and electronics\n        errors = []\n\n        for joint_name, temperature in self.joint_temperatures.items():\n            joint_type = self.get_joint_type(joint_name)\n            max_temp = self.temperature_limits.get(joint_type, 80.0)\n\n            if temperature > max_temp:\n                errors.append(f\"Joint {joint_name} temperature limit exceeded: {temperature:.2f}\xb0C, limit: {max_temp:.2f}\xb0C\")\n\n        return errors\n\n    def check_tracking_errors(self) -> List[str]:\n        \"\"\"Check position tracking errors\"\"\"\n        # WHAT: Verify that tracking errors are within acceptable limits\n        # WHY: Large tracking errors may indicate system problems or instability\n        errors = []\n\n        for joint_name, actual_pos in self.joint_positions.items():\n            desired_pos = self.joint_desired_positions.get(joint_name, actual_pos)\n            error = abs(actual_pos - desired_pos)\n\n            if error > self.error_threshold:\n                errors.append(f\"Joint {joint_name} tracking error too large: {math.degrees(error):.2f}\xb0, threshold: {math.degrees(self.error_threshold):.2f}\xb0\")\n\n        return errors\n\n    def get_joint_type(self, joint_name: str) -> str:\n        \"\"\"Determine joint type from name\"\"\"\n        # WHAT: Determine the type of joint from its name\n        # WHY: Different joint types have different safety limits\n        if 'hip' in joint_name:\n            return 'hip'\n        elif 'knee' in joint_name:\n            return 'knee'\n        elif 'ankle' in joint_name:\n            return 'ankle'\n        elif 'shoulder' in joint_name:\n            return 'shoulder'\n        elif 'elbow' in joint_name:\n            return 'elbow'\n        else:\n            return 'hip'  # default\n\n    def safety_check(self):\n        \"\"\"Execute comprehensive safety checks\"\"\"\n        # WHAT: Perform all safety checks and update system state accordingly\n        # WHY: Regular safety checks ensure safe robot operation\n        position_errors = self.check_position_limits()\n        velocity_errors = self.check_velocity_limits()\n        temperature_errors = self.check_temperature_limits()\n        tracking_errors = self.check_tracking_errors()\n\n        all_errors = position_errors + velocity_errors + temperature_errors + tracking_errors\n\n        # Update safety level based on errors\n        # WHAT: Determine the appropriate safety level based on the errors found\n        # WHY: Different safety levels require different responses\n        if all_errors:\n            # Log all errors\n            for error in all_errors:\n                self.get_logger().warning(error)\n\n            # Publish error report\n            error_msg = String()\n            error_msg.data = \"; \".join(all_errors)\n            self.error_publisher.publish(error_msg)\n\n            # Determine safety level based on error severity\n            critical_errors = [err for err in all_errors if 'temperature' in err or 'position' in err]\n            if critical_errors:\n                if self.safety_level != SafetyLevel.EMERGENCY:\n                    self.safety_level = SafetyLevel.EMERGENCY\n                    self.emergency_active = True\n                    self.last_emergency_time = self.get_clock().now()\n                    self.get_logger().error('CRITICAL SAFETY ERROR - Emergency stop initiated')\n                    self.publish_emergency_stop()\n            else:\n                if self.safety_level == SafetyLevel.NORMAL:\n                    self.safety_level = SafetyLevel.WARNING\n                    self.get_logger().warning('Safety warnings detected')\n        else:\n            # No errors, check if we can return to normal\n            if self.safety_level != SafetyLevel.NORMAL:\n                if self.safety_level == SafetyLevel.EMERGENCY:\n                    # Check if we can resume from emergency after a delay\n                    if (self.get_clock().now() - self.last_emergency_time).nanoseconds / 1e9 > 5.0:\n                        self.emergency_active = False\n                        self.safety_level = SafetyLevel.NORMAL\n                        self.get_logger().info('Safety conditions normalized, resuming operation')\n                    else:\n                        self.publish_emergency_stop()  # Keep emergency active\n                else:\n                    self.safety_level = SafetyLevel.NORMAL\n                    self.get_logger().info('Safety conditions normalized')\n\n        # Publish safety status\n        self.publish_safety_status()\n\n    def publish_emergency_stop(self):\n        \"\"\"Publish emergency stop command\"\"\"\n        # WHAT: Send an emergency stop command to halt all robot motion\n        # WHY: Emergency stop is critical for preventing damage or injury\n        stop_msg = Bool()\n        stop_msg.data = True\n        self.emergency_publisher.publish(stop_msg)\n\n    def publish_safety_status(self):\n        \"\"\"Publish current safety status\"\"\"\n        # WHAT: Publish the current safety status for monitoring\n        # WHY: Other nodes and operators need to know the safety state\n        status_msg = String()\n        status_msg.data = f\"Safety Level: {self.safety_level.value}\"\n        self.safety_status_publisher.publish(status_msg)\n\ndef main(args=None):\n    \"\"\"Main function to initialize and run the safety monitor\"\"\"\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n    safety_monitor = SafetyMonitor()\n\n    try:\n        # Start spinning the node to process callbacks\n        # WHAT: This starts the ROS 2 event loop, processing all callbacks\n        # WHY: Without spinning, the node wouldn't execute its timer and subscriber callbacks\n        rclpy.spin(safety_monitor)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        # WHAT: This handles the case when the user interrupts the program\n        # WHY: Provides a clean way to stop the safety monitor when needed\n        safety_monitor.get_logger().info('Shutting down safety monitor')\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        safety_monitor.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Dependencies"}),": ",(0,i.jsx)(t.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,i.jsx)(t.code,{children:"sensor_msgs"}),", ",(0,i.jsx)(t.code,{children:"std_msgs"}),", ",(0,i.jsx)(t.code,{children:"builtin_interfaces"})]}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(t.p,{children:"These exercises cover the implementation of control architectures for humanoid robots, from basic PID controllers to advanced trajectory controllers and safety monitoring systems. Each exercise builds on the concepts introduced in the chapter, providing practical implementations with proper error handling and safety considerations."})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}}}]);