"use strict";(globalThis.webpackChunkphysical_ai_book_humanoid=globalThis.webpackChunkphysical_ai_book_humanoid||[]).push([[233],{2720(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"examples/ros2-subscriber","title":"ROS 2 Subscriber Example","description":"Complete ROS 2 Subscriber Node with WHAT/WHY Comments","source":"@site/docs/examples/ros2-subscriber.md","sourceDirName":"examples","slug":"/examples/ros2-subscriber","permalink":"/docs/examples/ros2-subscriber","draft":false,"unlisted":false,"editUrl":"https://github.com/Panaversity/physical_ai_book_humanoid/tree/main/docs/examples/ros2-subscriber.md","tags":[],"version":"current","frontMatter":{}}');var o=s(4848),i=s(8453);const r={},a="ROS 2 Subscriber Example",c={},l=[{value:"Complete ROS 2 Subscriber Node with WHAT/WHY Comments",id:"complete-ros-2-subscriber-node-with-whatwhy-comments",level:2},{value:"Dependencies",id:"dependencies",level:2},{value:"How to Run",id:"how-to-run",level:2},{value:"Expected Output",id:"expected-output",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"ros-2-subscriber-example",children:"ROS 2 Subscriber Example"})}),"\n",(0,o.jsx)(n.h2,{id:"complete-ros-2-subscriber-node-with-whatwhy-comments",children:"Complete ROS 2 Subscriber Node with WHAT/WHY Comments"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Example: ROS 2 Subscriber Node for Humanoid Robot Joint States\n# WHAT: This code creates a ROS 2 subscriber node that receives joint state messages\n# WHY: To demonstrate the basic publish-subscribe communication pattern in ROS 2, which is fundamental for humanoid robot sensor feedback systems\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nimport time\n\nclass JointStateSubscriber(Node):\n    def __init__(self):\n        super().__init__('joint_state_subscriber')\n\n        # Create subscriber for joint states\n        # WHAT: This creates a subscriber that listens to joint state messages\n        # WHY: The robot needs to receive feedback about current joint positions, velocities, and efforts\n        self.subscription = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10  # QoS history depth\n        )\n\n        # Create publisher for processed joint data\n        # WHAT: This creates a publisher for processed joint information\n        # WHY: Processed data might be needed by other nodes in the system\n        self.processed_publisher = self.create_publisher(Float64MultiArray, 'processed_joint_data', 10)\n\n        # Store the most recent joint state\n        self.last_joint_state = None\n\n        self.get_logger().info('Joint State Subscriber node initialized')\n\n    def joint_state_callback(self, msg: JointState):\n        \"\"\"Process incoming joint state messages\"\"\"\n        # Store the received joint state\n        # WHAT: This saves the latest joint state message for potential later use\n        # WHY: Storing the state allows other parts of the node to access the most recent data\n        self.last_joint_state = msg\n\n        # Log the received joint names and positions\n        # WHAT: This logs the names and positions of all received joints\n        # WHY: Logging helps with debugging and monitoring the robot's state\n        if len(msg.name) == len(msg.position):\n            joint_info = []\n            for name, pos in zip(msg.name, msg.position):\n                joint_info.append(f\"{name}: {pos:.3f}\")\n            self.get_logger().info(f'Joint positions: {\", \".join(joint_info)}')\n\n        # Process the joint data to extract useful information\n        # WHAT: This calculates derived information from the raw joint data\n        # WHY: Derived information like joint velocity or acceleration might be needed for control\n        if len(msg.velocity) > 0:\n            avg_velocity = sum(abs(v) for v in msg.velocity) / len(msg.velocity)\n            self.get_logger().info(f'Average joint velocity: {avg_velocity:.3f}')\n\n        # Publish processed data\n        # WHAT: This publishes processed joint information to another topic\n        # WHY: Other nodes might need processed information rather than raw sensor data\n        if len(msg.position) > 0:\n            processed_msg = Float64MultiArray()\n            # Calculate some processed values (e.g., average position)\n            avg_position = sum(msg.position) / len(msg.position)\n            processed_msg.data = [avg_position, len(msg.position), avg_velocity]\n            self.processed_publisher.publish(processed_msg)\n\ndef main(args=None):\n    \"\"\"Main function to initialize and run the ROS 2 subscriber node\"\"\"\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n\n    # Create an instance of the JointStateSubscriber node\n    # WHAT: This creates the subscriber node instance\n    # WHY: The node contains all the logic for processing joint state messages\n    joint_subscriber = JointStateSubscriber()\n\n    try:\n        # Start spinning the node to process callbacks\n        # WHAT: This starts the ROS 2 event loop, processing incoming messages and other events\n        # WHY: Without spinning, the node wouldn't execute its callback functions to process messages\n        rclpy.spin(joint_subscriber)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        pass\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        joint_subscriber.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"sensor_msgs"})," - Sensor-related message types"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"std_msgs"})," - Standard ROS 2 message types"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"how-to-run",children:"How to Run"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Make sure your ROS 2 environment is sourced\nsource /opt/ros/kilted/setup.bash\n\n# Run the subscriber node\npython3 joint_state_subscriber.py\n"})}),"\n",(0,o.jsx)(n.h2,{id:"expected-output",children:"Expected Output"}),"\n",(0,o.jsx)(n.p,{children:"The subscriber will continuously log joint position and velocity information as it receives messages on the 'joint_states' topic. It will also publish processed joint data to the 'processed_joint_data' topic."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>r,x:()=>a});var t=s(6540);const o={},i=t.createContext(o);function r(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);