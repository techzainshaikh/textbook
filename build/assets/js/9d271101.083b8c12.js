"use strict";(globalThis.webpackChunkphysical_ai_book_humanoid=globalThis.webpackChunkphysical_ai_book_humanoid||[]).push([[774],{509(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-1-ros2/chapter-2-rclpy-agents","title":"Chapter 2 - rclpy-based Python Agents","description":"Developing Python nodes for humanoid robot control using rclpy","source":"@site/docs/module-1-ros2/chapter-2-rclpy-agents.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-2-rclpy-agents","permalink":"/docs/module-1-ros2/chapter-2-rclpy-agents","draft":false,"unlisted":false,"editUrl":"https://github.com/Panaversity/physical_ai_book_humanoid/tree/main/docs/module-1-ros2/chapter-2-rclpy-agents.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Chapter 2 - rclpy-based Python Agents","description":"Developing Python nodes for humanoid robot control using rclpy","keywords":["rclpy","python","ros2","agents","humanoid","control"]},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1 - Exercises","permalink":"/docs/module-1-ros2/chapter-1-exercises"},"next":{"title":"Chapter 2 - Exercises","permalink":"/docs/module-1-ros2/chapter-2-exercises"}}');var a=t(4848),i=t(8453);const o={sidebar_position:3,title:"Chapter 2 - rclpy-based Python Agents",description:"Developing Python nodes for humanoid robot control using rclpy",keywords:["rclpy","python","ros2","agents","humanoid","control"]},r="Chapter 2 - rclpy-based Python Agents",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Agent Architecture",id:"agent-architecture",level:3},{value:"State Management in Agents",id:"state-management-in-agents",level:3},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Creating a Basic Agent Structure",id:"creating-a-basic-agent-structure",level:3},{value:"Creating a State Machine Agent",id:"creating-a-state-machine-agent",level:3},{value:"Examples",id:"examples",level:2},{value:"Example: Multi-Agent Coordination",id:"example-multi-agent-coordination",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Conceptual",id:"conceptual",level:3},{value:"Logical",id:"logical",level:3},{value:"Implementation",id:"implementation-1",level:3}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chapter-2---rclpy-based-python-agents",children:"Chapter 2 - rclpy-based Python Agents"})}),"\n",(0,a.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(n.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Create sophisticated Python agents using the rclpy library"}),"\n",(0,a.jsx)(n.li,{children:"Implement state machines for humanoid robot behaviors"}),"\n",(0,a.jsx)(n.li,{children:"Design agent architectures with proper error handling and recovery"}),"\n",(0,a.jsx)(n.li,{children:"Integrate multiple ROS 2 communication patterns within a single agent"}),"\n",(0,a.jsx)(n.li,{children:"Apply design patterns for reusable and maintainable robot agents"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsx)(n.p,{children:"Before starting this chapter, students should have:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Completed Chapter 1 on Nodes, Topics, Services, and Actions"}),"\n",(0,a.jsx)(n.li,{children:"Solid understanding of Python programming"}),"\n",(0,a.jsx)(n.li,{children:"Basic knowledge of object-oriented design patterns"}),"\n",(0,a.jsx)(n.li,{children:"Understanding of humanoid robot kinematics and control concepts"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(n.h3,{id:"agent-architecture",children:"Agent Architecture"}),"\n",(0,a.jsx)(n.p,{children:"In robotics, an agent is an entity that perceives its environment through sensors and acts upon that environment through actuators. In the context of ROS 2 and humanoid robotics, an agent typically takes the form of a node that implements a specific behavior or function."}),"\n",(0,a.jsx)(n.p,{children:"A well-designed agent should:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Have a clear purpose and defined responsibilities"}),"\n",(0,a.jsx)(n.li,{children:"Respond appropriately to environmental changes"}),"\n",(0,a.jsx)(n.li,{children:"Maintain internal state to make informed decisions"}),"\n",(0,a.jsx)(n.li,{children:"Handle errors gracefully and attempt recovery"}),"\n",(0,a.jsx)(n.li,{children:"Communicate effectively with other agents in the system"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"state-management-in-agents",children:"State Management in Agents"}),"\n",(0,a.jsx)(n.p,{children:"Humanoid robots operate in dynamic environments that require complex decision-making. Agents need to maintain state to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Track the robot's current situation"}),"\n",(0,a.jsx)(n.li,{children:"Remember past events and decisions"}),"\n",(0,a.jsx)(n.li,{children:"Plan future actions based on context"}),"\n",(0,a.jsx)(n.li,{children:"Coordinate with other agents"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,a.jsx)(n.p,{children:"Robots must operate reliably in real-world conditions where failures are inevitable. Good agent design includes:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Comprehensive error detection and logging"}),"\n",(0,a.jsx)(n.li,{children:"Graceful degradation when components fail"}),"\n",(0,a.jsx)(n.li,{children:"Recovery strategies for common failure modes"}),"\n",(0,a.jsx)(n.li,{children:"Safe states that prevent damage to the robot or environment"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)(n.h3,{id:"creating-a-basic-agent-structure",children:"Creating a Basic Agent Structure"}),"\n",(0,a.jsx)(n.p,{children:"Let's create a foundational agent structure that can be extended for specific humanoid robot behaviors:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Example: Base Humanoid Agent\n# WHAT: This code creates a base class for humanoid robot agents with common functionality\n# WHY: To provide a reusable foundation for implementing specific robot behaviors\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.qos import QoSProfile\nfrom std_msgs.msg import String, Bool\nfrom sensor_msgs.msg import JointState\nfrom geometry_msgs.msg import Twist\nfrom builtin_interfaces.msg import Time\nimport time\nfrom enum import Enum\nfrom typing import Dict, Any, Optional\n\nclass AgentState(Enum):\n    """Enumeration of possible agent states"""\n    IDLE = "idle"\n    ACTIVE = "active"\n    ERROR = "error"\n    SHUTDOWN = "shutdown"\n\nclass HumanoidAgent(Node):\n    def __init__(self, agent_name: str):\n        super().__init__(agent_name)\n\n        # Agent state management\n        # WHAT: These variables track the current state of the agent\n        # WHY: State management is crucial for handling different operational modes\n        self.state = AgentState.IDLE\n        self.agent_name = agent_name\n        self.last_error: Optional[str] = None\n        self.start_time = self.get_clock().now()\n\n        # Publishers for agent status\n        # WHAT: These publishers send status and error information to other nodes\n        # WHY: Other nodes need to know the agent\'s state for coordination\n        self.status_publisher = self.create_publisher(String, f\'/{agent_name}/status\', 10)\n        self.error_publisher = self.create_publisher(String, f\'/{agent_name}/error\', 10)\n\n        # Subscriber for joint states (common for humanoid robots)\n        # WHAT: This subscribes to joint state messages from the robot\n        # WHY: Joint states are needed for many humanoid robot behaviors\n        self.joint_state_subscriber = self.create_subscription(\n            JointState,\n            \'joint_states\',\n            self.joint_state_callback,\n            10\n        )\n\n        # Timer for periodic status updates\n        # WHAT: This timer periodically publishes the agent\'s status\n        # WHY: Continuous status updates help with monitoring and debugging\n        self.status_timer = self.create_timer(1.0, self.publish_status)\n\n        # Initialize agent-specific components\n        # WHAT: This calls a method to initialize subclass-specific components\n        # WHY: Allows subclasses to add their own initialization logic\n        self._initialize_components()\n\n        self.get_logger().info(f\'Agent {agent_name} initialized in {self.state.value} state\')\n\n    def _initialize_components(self):\n        """Initialize agent-specific components - to be overridden by subclasses"""\n        # WHAT: This method is meant to be overridden by subclasses\n        # WHY: Allows specific agents to initialize their unique components\n        pass\n\n    def joint_state_callback(self, msg: JointState):\n        """Process joint state messages"""\n        # WHAT: This method processes incoming joint state messages\n        # WHY: Joint states provide critical information about the robot\'s configuration\n        # This method can be overridden by subclasses\n        pass\n\n    def publish_status(self):\n        """Publish current agent status"""\n        # WHAT: This method publishes the current agent status\n        # WHY: Other nodes and monitoring systems need to know the agent\'s state\n        status_msg = String()\n        status_msg.data = f"{self.agent_name}: {self.state.value}"\n        self.status_publisher.publish(status_msg)\n\n    def publish_error(self, error_msg: str):\n        """Publish error information"""\n        # WHAT: This method publishes error information to the error topic\n        # WHY: Error information needs to be communicated to monitoring systems\n        error_string = String()\n        error_string.data = f"{self.agent_name}: {error_msg}"\n        self.error_publisher.publish(error_string)\n        self.last_error = error_msg\n\n    def transition_state(self, new_state: AgentState):\n        """Safely transition between states"""\n        # WHAT: This method safely transitions the agent to a new state\n        # WHY: Proper state transitions are important for maintaining system consistency\n        old_state = self.state\n        self.state = new_state\n        self.get_logger().info(f\'State transition: {old_state.value} -> {new_state.value}\')\n\n    def enter_error_state(self, error_msg: str):\n        """Enter error state with error message"""\n        # WHAT: This method transitions the agent to an error state\n        # WHY: Error states indicate problems that need attention or recovery\n        self.publish_error(error_msg)\n        self.transition_state(AgentState.ERROR)\n\n    def enter_active_state(self):\n        """Enter active state"""\n        # WHAT: This method transitions the agent to an active state\n        # WHY: Active state indicates the agent is performing its primary function\n        self.transition_state(AgentState.ACTIVE)\n\n    def enter_idle_state(self):\n        """Enter idle state"""\n        # WHAT: This method transitions the agent to an idle state\n        # WHY: Idle state indicates the agent is ready but not currently active\n        self.transition_state(AgentState.IDLE)\n\n    def get_uptime(self) -> float:\n        """Get time since agent started"""\n        # WHAT: This method calculates the time since the agent started\n        # WHY: Uptime information is useful for monitoring and debugging\n        current_time = self.get_clock().now()\n        duration = current_time - self.start_time\n        return duration.nanoseconds / 1e9\n\nclass BalanceControllerAgent(HumanoidAgent):\n    def __init__(self):\n        super().__init__(\'balance_controller\')\n\n        # Balance-specific publishers and subscribers\n        # WHAT: These are specific to the balance control functionality\n        # WHY: Balance control needs to send velocity commands and publish CoM data\n        self.cmd_vel_publisher = self.create_publisher(Twist, \'cmd_vel\', 10)\n        self.com_publisher = self.create_publisher(String, \'center_of_mass\', 10)\n\n        # Timer for balance control loop\n        # WHAT: This timer runs the balance control algorithm at 20Hz\n        # WHY: Balance control needs to run at a high frequency for stability\n        self.balance_timer = self.create_timer(0.05, self.balance_control_loop)  # 20Hz\n\n        # Balance control parameters\n        # WHAT: These parameters define the balance control thresholds and state\n        # WHY: Parameters allow tuning of the balance algorithm\n        self.com_threshold = 0.05  # Center of mass threshold in meters\n        self.current_com = {\'x\': 0.0, \'y\': 0.0, \'z\': 0.0}\n        self.balance_active = False\n\n    def _initialize_components(self):\n        """Initialize balance controller specific components"""\n        # WHAT: This method initializes components specific to the balance controller\n        # WHY: Provides a place to set up balance-specific initialization\n        self.get_logger().info(\'Balance controller initialized\')\n\n    def joint_state_callback(self, msg: JointState):\n        """Process joint states to calculate center of mass"""\n        # WHAT: This method calculates the center of mass from joint positions\n        # WHY: Center of mass is critical for balance control\n        # Simplified CoM calculation based on joint positions\n        # In a real implementation, this would use the robot\'s URDF and kinematics\n        if \'left_foot_joint\' in msg.name and \'right_foot_joint\' in msg.name:\n            left_idx = msg.name.index(\'left_foot_joint\')\n            right_idx = msg.name.index(\'right_foot_joint\')\n\n            # Calculate approximate center of mass\n            # WHAT: This calculates the X position of the center of mass\n            # WHY: The X position is important for forward-back balance\n            self.current_com[\'x\'] = (msg.position[left_idx] + msg.position[right_idx]) / 2.0\n\n    def balance_control_loop(self):\n        """Main balance control loop"""\n        # WHAT: This is the main control loop for maintaining balance\n        # WHY: Balance needs to be continuously maintained during operation\n        if self.state != AgentState.ACTIVE:\n            return\n\n        # Check if center of mass is within safe bounds\n        # WHAT: This checks if the center of mass has exceeded the threshold\n        # WHY: Excessive CoM deviation indicates potential loss of balance\n        if abs(self.current_com[\'x\']) > self.com_threshold:\n            self.get_logger().warning(f\'Center of mass exceeded threshold: {self.current_com["x"]:.3f}\')\n\n            # Generate corrective movement\n            # WHAT: This generates a velocity command to correct the CoM position\n            # WHY: Corrective movement helps restore balance\n            cmd_msg = Twist()\n            cmd_msg.linear.x = -0.1 * self.current_com[\'x\']  # Proportional control\n            self.cmd_vel_publisher.publish(cmd_msg)\n\n            # Publish CoM info for monitoring\n            # WHAT: This publishes CoM information for monitoring purposes\n            # WHY: Monitoring systems need to track CoM for analysis\n            com_msg = String()\n            com_msg.data = f"CoM: x={self.current_com[\'x\']:.3f}, threshold={self.com_threshold:.3f}"\n            self.com_publisher.publish(com_msg)\n\ndef main(args=None):\n    """Main function to initialize and run the balance controller agent"""\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n    balance_agent = BalanceControllerAgent()\n    balance_agent.enter_active_state()\n\n    try:\n        # Start spinning the node to process callbacks\n        # WHAT: This starts the ROS 2 event loop, processing all callbacks\n        # WHY: Without spinning, the node wouldn\'t execute its timer and subscriber callbacks\n        rclpy.spin(balance_agent)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        # WHAT: This handles the case when the user interrupts the program\n        # WHY: Provides a clean way to stop the agent when needed\n        balance_agent.get_logger().info(\'Shutting down balance controller agent\')\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        balance_agent.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Dependencies"}),": ",(0,a.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,a.jsx)(n.code,{children:"std_msgs"}),", ",(0,a.jsx)(n.code,{children:"sensor_msgs"}),", ",(0,a.jsx)(n.code,{children:"geometry_msgs"})]}),"\n",(0,a.jsx)(n.h3,{id:"creating-a-state-machine-agent",children:"Creating a State Machine Agent"}),"\n",(0,a.jsx)(n.p,{children:"Here's an example of a more complex agent using a state machine pattern:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Example: Walking State Machine Agent\n# WHAT: This code creates a state machine-based agent for humanoid walking control\n# WHY: To demonstrate complex behavior management using state machines\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Bool, Float32\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist\nfrom builtin_interfaces.msg import Time\nimport time\nfrom enum import Enum\nfrom typing import Dict, Any, Optional\nimport math\n\nclass WalkingState(Enum):\n    """Walking-specific states"""\n    STANDING = "standing"\n    PREPARING_STEP = "preparing_step"\n    STEPPING = "stepping"\n    BALANCING = "balancing"\n    EMERGENCY_STOP = "emergency_stop"\n\nclass WalkingStateMachineAgent(Node):\n    def __init__(self):\n        super().__init__(\'walking_state_machine\')\n\n        # State management\n        self.current_state = WalkingState.STANDING\n        self.previous_state = WalkingState.STANDING\n        self.state_start_time = self.get_clock().now()\n\n        # Publishers\n        self.joint_cmd_publisher = self.create_publisher(JointState, \'joint_commands\', 10)\n        self.state_publisher = self.create_publisher(String, \'walking_state\', 10)\n        self.cmd_vel_publisher = self.create_publisher(Twist, \'cmd_vel\', 10)\n\n        # Subscribers\n        self.joint_state_subscriber = self.create_subscription(\n            JointState, \'joint_states\', self.joint_state_callback, 10\n        )\n        self.imu_subscriber = self.create_subscription(\n            Imu, \'imu_data\', self.imu_callback, 10\n        )\n        self.cmd_vel_subscriber = self.create_subscription(\n            Twist, \'cmd_vel_request\', self.cmd_vel_request_callback, 10\n        )\n\n        # Timers\n        self.state_machine_timer = self.create_timer(0.02, self.state_machine_step)  # 50Hz\n        self.state_publisher_timer = self.create_timer(0.5, self.publish_state)\n\n        # Walking parameters\n        self.step_height = 0.05  # meters\n        self.step_length = 0.3   # meters\n        self.step_duration = 1.0 # seconds\n        self.balance_threshold = 0.1  # meters\n        self.imu_data = {\'roll\': 0.0, \'pitch\': 0.0, \'yaw\': 0.0}\n        self.joint_positions = {}\n        self.cmd_vel_request = Twist()\n        self.is_moving = False\n\n        # Walking state variables\n        self.step_progress = 0.0\n        self.support_foot = \'left\'  # \'left\' or \'right\'\n        self.swing_foot = \'right\'   # \'left\' or \'right\'\n\n        self.get_logger().info(\'Walking State Machine Agent initialized\')\n\n    def joint_state_callback(self, msg: JointState):\n        """Process joint state messages"""\n        for name, position in zip(msg.name, msg.position):\n            self.joint_positions[name] = position\n\n    def imu_callback(self, msg: Imu):\n        """Process IMU data"""\n        # Extract roll, pitch, yaw from quaternion\n        x = msg.orientation.x\n        y = msg.orientation.y\n        z = msg.orientation.z\n        w = msg.orientation.w\n\n        # Simplified conversion (assuming small yaw)\n        roll = math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y))\n        pitch = math.asin(2 * (w * y - z * x))\n\n        self.imu_data[\'roll\'] = roll\n        self.imu_data[\'pitch\'] = pitch\n\n    def cmd_vel_request_callback(self, msg: Twist):\n        """Handle velocity commands"""\n        self.cmd_vel_request = msg\n        self.is_moving = abs(msg.linear.x) > 0.01 or abs(msg.angular.z) > 0.01\n\n    def state_machine_step(self):\n        """Main state machine execution step"""\n        # Check for emergency conditions first\n        if abs(self.imu_data[\'pitch\']) > 0.5 or abs(self.imu_data[\'roll\']) > 0.5:\n            if self.current_state != WalkingState.EMERGENCY_STOP:\n                self.transition_to_state(WalkingState.EMERGENCY_STOP)\n            return\n\n        # Execute current state\n        if self.current_state == WalkingState.STANDING:\n            self.execute_standing_state()\n        elif self.current_state == WalkingState.PREPARING_STEP:\n            self.execute_preparing_step_state()\n        elif self.current_state == WalkingState.STEPPING:\n            self.execute_stepping_state()\n        elif self.current_state == WalkingState.BALANCING:\n            self.execute_balancing_state()\n        elif self.current_state == WalkingState.EMERGENCY_STOP:\n            self.execute_emergency_stop_state()\n\n    def execute_standing_state(self):\n        """Execute standing state logic"""\n        if self.is_moving:\n            self.transition_to_state(WalkingState.PREPARING_STEP)\n        else:\n            # Maintain standing position with minimal adjustments\n            self.publish_standing_joints()\n\n    def execute_preparing_step_state(self):\n        """Execute step preparation state"""\n        # Prepare to shift weight to support foot\n        self.step_progress += 0.02  # 50Hz * 0.02 = 1.0 per second\n\n        if self.step_progress >= 1.0:\n            self.transition_to_state(WalkingState.STEPPING)\n            self.step_progress = 0.0\n\n    def execute_stepping_state(self):\n        """Execute actual stepping motion"""\n        self.step_progress += 0.02  # 50Hz * 0.02 = 1.0 per step_duration\n\n        if self.step_progress >= 1.0:\n            # Step completed, switch support foot\n            self.support_foot, self.swing_foot = self.swing_foot, self.support_foot\n            self.transition_to_state(WalkingState.BALANCING)\n            self.step_progress = 0.0\n        else:\n            # Execute step trajectory\n            self.execute_step_trajectory()\n\n    def execute_balancing_state(self):\n        """Execute post-step balancing"""\n        self.step_progress += 0.02\n\n        if self.step_progress >= 0.5 or self.is_balance_stable():\n            if self.is_moving:\n                self.transition_to_state(WalkingState.PREPARING_STEP)\n            else:\n                self.transition_to_state(WalkingState.STANDING)\n            self.step_progress = 0.0\n\n    def execute_emergency_stop_state(self):\n        """Execute emergency stop procedures"""\n        # Move to safe position\n        self.publish_safe_joints()\n        self.get_logger().warning(\'Emergency stop activated - robot is in safe position\')\n\n        # Check if it\'s safe to resume\n        if abs(self.imu_data[\'pitch\']) < 0.2 and abs(self.imu_data[\'roll\']) < 0.2:\n            self.transition_to_state(WalkingState.STANDING)\n\n    def is_balance_stable(self) -> bool:\n        """Check if robot is in stable balance"""\n        return abs(self.imu_data[\'pitch\']) < self.balance_threshold and \\\n               abs(self.imu_data[\'roll\']) < self.balance_threshold\n\n    def execute_step_trajectory(self):\n        """Execute the step trajectory for the swing foot"""\n        # Calculate step trajectory based on progress\n        t = self.step_progress\n        height_factor = math.sin(math.pi * t) * self.step_height\n        forward_factor = t * self.step_length\n\n        # Generate appropriate joint commands for the step\n        joint_cmd = JointState()\n        joint_cmd.header.stamp = self.get_clock().now().to_msg()\n        joint_cmd.name = [\'left_hip\', \'left_knee\', \'left_ankle\', \'right_hip\', \'right_knee\', \'right_ankle\']\n        joint_cmd.position = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  # Placeholder values\n\n        self.joint_cmd_publisher.publish(joint_cmd)\n\n    def publish_standing_joints(self):\n        """Publish joint positions for standing posture"""\n        joint_cmd = JointState()\n        joint_cmd.header.stamp = self.get_clock().now().to_msg()\n        joint_cmd.name = [\'left_hip\', \'left_knee\', \'left_ankle\', \'right_hip\', \'right_knee\', \'right_ankle\']\n        joint_cmd.position = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  # Standing position\n\n        self.joint_cmd_publisher.publish(joint_cmd)\n\n    def publish_safe_joints(self):\n        """Publish joint positions for safe posture"""\n        joint_cmd = JointState()\n        joint_cmd.header.stamp = self.get_clock().now().to_msg()\n        joint_cmd.name = [\'left_hip\', \'left_knee\', \'left_ankle\', \'right_hip\', \'right_knee\', \'right_ankle\']\n        joint_cmd.position = [0.0, -0.5, 0.5, 0.0, -0.5, 0.5]  # Safe position\n\n        self.joint_cmd_publisher.publish(joint_cmd)\n\n    def transition_to_state(self, new_state: WalkingState):\n        """Safely transition to a new state"""\n        self.previous_state = self.current_state\n        self.current_state = new_state\n        self.state_start_time = self.get_clock().now()\n        self.get_logger().info(f\'Walking state transition: {self.previous_state.value} -> {new_state.value}\')\n\n        # Publish state change\n        state_msg = String()\n        state_msg.data = new_state.value\n        self.state_publisher.publish(state_msg)\n\n    def publish_state(self):\n        """Publish current walking state"""\n        state_msg = String()\n        state_msg.data = self.current_state.value\n        self.state_publisher.publish(state_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    walking_agent = WalkingStateMachineAgent()\n\n    try:\n        rclpy.spin(walking_agent)\n    except KeyboardInterrupt:\n        walking_agent.get_logger().info(\'Shutting down walking state machine agent\')\n    finally:\n        walking_agent.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Dependencies"}),": ",(0,a.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,a.jsx)(n.code,{children:"std_msgs"}),", ",(0,a.jsx)(n.code,{children:"sensor_msgs"}),", ",(0,a.jsx)(n.code,{children:"geometry_msgs"})]}),"\n",(0,a.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(n.h3,{id:"example-multi-agent-coordination",children:"Example: Multi-Agent Coordination"}),"\n",(0,a.jsx)(n.p,{children:"Here's an example of how multiple agents can coordinate in a humanoid robot system:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Example: Agent Coordinator\n# WHAT: This code creates a coordinator agent that manages multiple specialized agents\n# WHY: To demonstrate how to coordinate multiple agents for complex humanoid behaviors\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Bool\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import JointState\nfrom builtin_interfaces.msg import Time\nimport time\nfrom typing import Dict, Any, List\nimport threading\n\nclass AgentCoordinator(Node):\n    def __init__(self):\n        super().__init__(\'agent_coordinator\')\n\n        # Publishers\n        self.coordinator_status_publisher = self.create_publisher(\n            String, \'coordinator_status\', 10\n        )\n        self.system_cmd_publisher = self.create_publisher(\n            String, \'system_commands\', 10\n        )\n\n        # Subscribers\n        self.agent_status_subscriber = self.create_subscription(\n            String, \'agent_status\', self.agent_status_callback, 10\n        )\n        self.system_control_subscriber = self.create_subscription(\n            String, \'system_control\', self.system_control_callback, 10\n        )\n\n        # Timer for coordination logic\n        self.coordination_timer = self.create_timer(0.1, self.coordination_step)\n\n        # Agent management\n        self.active_agents: Dict[str, Dict[str, Any]] = {}\n        self.agent_commands: List[str] = []\n        self.system_state = "idle"\n        self.last_coordination_time = self.get_clock().now()\n\n        # Initialize agent registry\n        self.register_default_agents()\n\n        self.get_logger().info(\'Agent Coordinator initialized\')\n\n    def register_default_agents(self):\n        """Register known agents in the system"""\n        default_agents = [\n            "balance_controller",\n            "walking_controller",\n            "arm_controller",\n            "head_controller",\n            "navigation_agent"\n        ]\n\n        for agent_name in default_agents:\n            self.active_agents[agent_name] = {\n                "status": "unknown",\n                "last_seen": self.get_clock().now(),\n                "capabilities": []\n            }\n\n    def agent_status_callback(self, msg: String):\n        """Process agent status updates"""\n        # Parse status message (format: "agent_name: status")\n        if ":" in msg.data:\n            agent_name, status = msg.data.split(":", 1)\n            agent_name = agent_name.strip()\n            status = status.strip()\n\n            if agent_name in self.active_agents:\n                self.active_agents[agent_name]["status"] = status\n                self.active_agents[agent_name]["last_seen"] = self.get_clock().now()\n                self.get_logger().debug(f\'Updated status for {agent_name}: {status}\')\n            else:\n                # Register new agent if not in registry\n                self.active_agents[agent_name] = {\n                    "status": status,\n                    "last_seen": self.get_clock().now(),\n                    "capabilities": []\n                }\n                self.get_logger().info(f\'Registered new agent: {agent_name}\')\n\n    def system_control_callback(self, msg: String):\n        """Process system control commands"""\n        command = msg.data.lower().strip()\n        self.agent_commands.append(command)\n        self.get_logger().info(f\'Received system command: {command}\')\n\n    def coordination_step(self):\n        """Main coordination logic step"""\n        current_time = self.get_clock().now()\n\n        # Check for timed out agents\n        timeout_threshold = rclpy.time.Duration(seconds=5.0)\n        for agent_name, agent_info in self.active_agents.items():\n            time_since_seen = current_time - agent_info["last_seen"]\n            if time_since_seen > timeout_threshold:\n                self.get_logger().warning(f\'Agent {agent_name} appears to be unresponsive\')\n                # Could trigger recovery procedures here\n\n        # Process any pending commands\n        while self.agent_commands:\n            command = self.agent_commands.pop(0)\n            self.execute_command(command)\n\n        # Publish coordinator status\n        status_msg = String()\n        active_count = sum(1 for info in self.active_agents.values() if info["status"] != "error")\n        status_msg.data = f"Coordinator: {active_count}/{len(self.active_agents)} agents active"\n        self.coordinator_status_publisher.publish(status_msg)\n\n    def execute_command(self, command: str):\n        """Execute a system command"""\n        if command == "start_walking":\n            self.send_command_to_agent("walking_controller", "start")\n            self.send_command_to_agent("balance_controller", "activate")\n        elif command == "stop_walking":\n            self.send_command_to_agent("walking_controller", "stop")\n            self.send_command_to_agent("balance_controller", "deactivate")\n        elif command == "emergency_stop":\n            self.emergency_stop_all_agents()\n        elif command == "system_check":\n            self.perform_system_check()\n        else:\n            self.get_logger().warning(f\'Unknown command: {command}\')\n\n    def send_command_to_agent(self, agent_name: str, command: str):\n        """Send a command to a specific agent"""\n        if agent_name in self.active_agents:\n            cmd_msg = String()\n            cmd_msg.data = f"{agent_name}: {command}"\n            self.system_cmd_publisher.publish(cmd_msg)\n            self.get_logger().info(f\'Sent command to {agent_name}: {command}\')\n        else:\n            self.get_logger().warning(f\'Cannot send command to unknown agent: {agent_name}\')\n\n    def emergency_stop_all_agents(self):\n        """Send emergency stop to all agents"""\n        self.get_logger().warning(\'Sending emergency stop to all agents\')\n        for agent_name in self.active_agents.keys():\n            self.send_command_to_agent(agent_name, "emergency_stop")\n\n    def perform_system_check(self):\n        """Perform a system health check"""\n        self.get_logger().info(\'Performing system health check\')\n\n        report = []\n        for agent_name, agent_info in self.active_agents.items():\n            status = agent_info["status"]\n            report.append(f"{agent_name}: {status}")\n\n        self.get_logger().info(\'System health report: \' + \', \'.join(report))\n\ndef main(args=None):\n    rclpy.init(args=args)\n    coordinator = AgentCoordinator()\n\n    try:\n        rclpy.spin(coordinator)\n    except KeyboardInterrupt:\n        coordinator.get_logger().info(\'Shutting down agent coordinator\')\n    finally:\n        coordinator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Dependencies"}),": ",(0,a.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,a.jsx)(n.code,{children:"std_msgs"}),", ",(0,a.jsx)(n.code,{children:"geometry_msgs"}),", ",(0,a.jsx)(n.code,{children:"sensor_msgs"})]}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"In this chapter, we've explored the development of sophisticated Python agents for humanoid robot control using rclpy. We covered:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Agent Architecture"}),": Creating reusable base classes for robot agents"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"State Management"}),": Implementing state machines for complex behaviors"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Error Handling"}),": Designing robust error detection and recovery mechanisms"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multi-Agent Coordination"}),": Managing multiple specialized agents"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"These concepts are crucial for building reliable and maintainable humanoid robot systems. Well-designed agents form the building blocks of complex robotic behaviors and enable modular, scalable robot architectures."}),"\n",(0,a.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,a.jsx)(n.h3,{id:"conceptual",children:"Conceptual"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Explain the advantages and disadvantages of using a state machine versus a behavior tree for humanoid robot control."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"logical",children:"Logical"}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsx)(n.li,{children:"Design an agent architecture for a humanoid robot that can walk, pick up objects, and navigate around obstacles. Identify the different agents needed and their interactions."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,a.jsxs)(n.ol,{start:"3",children:["\n",(0,a.jsx)(n.li,{children:"Implement a Python agent that monitors joint temperatures and implements a safety system that reduces motor power when temperatures exceed safe thresholds. Include proper logging and error handling."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>r});var s=t(6540);const a={},i=s.createContext(a);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);