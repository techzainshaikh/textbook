"use strict";(globalThis.webpackChunkphysical_ai_book_humanoid=globalThis.webpackChunkphysical_ai_book_humanoid||[]).push([[7863],{3696(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>f,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-1-ros2/chapter-4-control-architecture","title":"Chapter 4 - ROS 2 Control Architecture","description":"Designing control systems for humanoid robots using ROS 2","source":"@site/docs/module-1-ros2/chapter-4-control-architecture.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-4-control-architecture","permalink":"/textbook/docs/module-1-ros2/chapter-4-control-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/Panaversity/physical_ai_book_humanoid/tree/main/docs/module-1-ros2/chapter-4-control-architecture.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Chapter 4 - ROS 2 Control Architecture","description":"Designing control systems for humanoid robots using ROS 2","keywords":["ros2","control","humanoid","robotics","architecture","controllers"]},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3 - Exercises","permalink":"/textbook/docs/module-1-ros2/chapter-3-exercises"},"next":{"title":"Chapter 4 - Exercises","permalink":"/textbook/docs/module-1-ros2/chapter-4-exercises"}}');var r=t(4848),i=t(8453);const s={sidebar_position:5,title:"Chapter 4 - ROS 2 Control Architecture",description:"Designing control systems for humanoid robots using ROS 2",keywords:["ros2","control","humanoid","robotics","architecture","controllers"]},a="Chapter 4 - ROS 2 Control Architecture",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Control Architecture Overview",id:"control-architecture-overview",level:3},{value:"Control Loop Fundamentals",id:"control-loop-fundamentals",level:3},{value:"ROS 2 Control Framework",id:"ros-2-control-framework",level:3},{value:"Forward and Inverse Dynamics",id:"forward-and-inverse-dynamics",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Basic Joint Controller Implementation",id:"basic-joint-controller-implementation",level:3},{value:"Advanced Control: Whole-Body Controller",id:"advanced-control-whole-body-controller",level:3},{value:"Safety and Error Handling Controller",id:"safety-and-error-handling-controller",level:3},{value:"Examples",id:"examples",level:2},{value:"Example: Walking Controller with Trajectory Generation",id:"example-walking-controller-with-trajectory-generation",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Conceptual",id:"conceptual",level:3},{value:"Logical",id:"logical",level:3},{value:"Implementation",id:"implementation-1",level:3}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-4---ros-2-control-architecture",children:"Chapter 4 - ROS 2 Control Architecture"})}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Design control architectures for humanoid robots using ROS 2"}),"\n",(0,r.jsx)(n.li,{children:"Implement joint controllers with proper feedback and control loops"}),"\n",(0,r.jsx)(n.li,{children:"Create high-level controllers for complex humanoid behaviors"}),"\n",(0,r.jsx)(n.li,{children:"Integrate perception and control systems for closed-loop operation"}),"\n",(0,r.jsx)(n.li,{children:"Design fail-safe mechanisms and error recovery strategies for control systems"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsx)(n.p,{children:"Before starting this chapter, students should have:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Understanding of basic control theory (PID, feedback loops)"}),"\n",(0,r.jsx)(n.li,{children:"Knowledge of ROS 2 communication patterns and message types"}),"\n",(0,r.jsx)(n.li,{children:"Experience with URDF modeling from Chapter 3"}),"\n",(0,r.jsx)(n.li,{children:"Understanding of humanoid robot kinematics and dynamics"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"control-architecture-overview",children:"Control Architecture Overview"}),"\n",(0,r.jsx)(n.p,{children:"Humanoid robot control involves multiple layers:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Low-level Joint Control"}),": Direct motor control and position/velocity/effort control"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mid-level Motion Control"}),": Trajectory generation and interpolation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High-level Behavior Control"}),": Complex behaviors like walking, manipulation, and navigation"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"control-loop-fundamentals",children:"Control Loop Fundamentals"}),"\n",(0,r.jsx)(n.p,{children:"A basic control loop follows the pattern:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensing"}),": Read current state from sensors"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Calculation"}),": Compare desired vs. actual state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Control Law"}),": Apply control algorithm (e.g., PID) to compute command"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Actuation"}),": Send command to actuators"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Repeat"}),": Continuously update based on sensor feedback"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For a control system with desired state r(t), actual state y(t), and control output u(t):"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Error: e(t) = r(t) - y(t)"}),"\n",(0,r.jsxs)(n.li,{children:["Control law: u(t) = f(e(t)) (e.g., PID: u(t) = K",(0,r.jsx)("sub",{children:"p"}),"e(t) + K",(0,r.jsx)("sub",{children:"i"}),"\u222be(t)dt + K",(0,r.jsx)("sub",{children:"d"}),"de(t)/dt)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"ros-2-control-framework",children:"ROS 2 Control Framework"}),"\n",(0,r.jsxs)(n.p,{children:["ROS 2 provides the ",(0,r.jsx)(n.code,{children:"ros2_control"})," framework which includes:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hardware Interface"}),": Abstraction layer for physical hardware"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Controller Manager"}),": Runtime management of controllers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Controllers"}),": Specific control algorithms (position, velocity, effort)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Joint State Broadcaster"}),": Publishing joint states for visualization and feedback"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"forward-and-inverse-dynamics",children:"Forward and Inverse Dynamics"}),"\n",(0,r.jsx)(n.p,{children:"For controlling humanoid robots, understanding both:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Forward Dynamics"}),": Given joint torques, compute accelerations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inverse Dynamics"}),": Given desired motion, compute required torques"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"basic-joint-controller-implementation",children:"Basic Joint Controller Implementation"}),"\n",(0,r.jsx)(n.p,{children:"Let's create a basic joint controller for humanoid robot joints:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Example: Joint Position Controller\n# WHAT: This code implements a PID-based joint position controller for humanoid robots\n# WHY: To demonstrate fundamental joint control with feedback and safety mechanisms\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nfrom control_msgs.msg import JointTrajectoryControllerState\nfrom builtin_interfaces.msg import Duration\nimport numpy as np\nimport math\nfrom typing import Dict, List, Tuple\n\nclass JointPositionController(Node):\n    def __init__(self):\n        super().__init__('joint_position_controller')\n\n        # Controller parameters\n        # WHAT: Define the joint names for the controller\n        # WHY: These are the specific joints that will be controlled by this controller\n        self.joint_names = [\n            'left_hip', 'left_knee', 'left_ankle',\n            'right_hip', 'right_knee', 'right_ankle',\n            'left_shoulder', 'left_elbow', 'right_shoulder', 'right_elbow'\n        ]\n\n        # PID gains for each joint (tunable parameters)\n        # WHAT: Define proportional, integral, and derivative gains for PID control\n        # WHY: PID control provides stable and responsive joint position control\n        self.kp = {name: 100.0 for name in self.joint_names}  # Proportional gain\n        self.ki = {name: 0.1 for name in self.joint_names}    # Integral gain\n        self.kd = {name: 10.0 for name in self.joint_names}   # Derivative gain\n\n        # Joint state variables\n        # WHAT: Store current and desired positions, velocities, and efforts for each joint\n        # WHY: These variables are needed for control calculations and feedback\n        self.current_positions = {name: 0.0 for name in self.joint_names}\n        self.current_velocities = {name: 0.0 for name in self.joint_names}\n        self.current_efforts = {name: 0.0 for name in self.joint_names}\n        self.desired_positions = {name: 0.0 for name in self.joint_names}\n        self.commanded_efforts = {name: 0.0 for name in self.joint_names}\n\n        # PID integral and derivative terms\n        # WHAT: Store historical values needed for PID calculations\n        # WHY: These values are needed to compute the integral and derivative components of PID\n        self.integral_errors = {name: 0.0 for name in self.joint_names}\n        self.previous_errors = {name: 0.0 for name in self.joint_names}\n\n        # Control loop timing\n        # WHAT: Track the time of the last control update\n        # WHY: Needed to calculate time delta for integration and differentiation\n        self.last_update_time = self.get_clock().now()\n\n        # Publishers and subscribers\n        # WHAT: Create publisher for sending joint effort commands\n        # WHY: Commands need to be sent to the robot's actuators\n        self.joint_command_publisher = self.create_publisher(\n            Float64MultiArray, '/effort_commands', 10\n        )\n\n        # WHAT: Create subscriber for receiving current joint states\n        # WHY: Feedback is needed to compute control errors\n        self.joint_state_subscriber = self.create_subscription(\n            JointState, '/joint_states', self.joint_state_callback, 10\n        )\n\n        # WHAT: Create subscriber for receiving trajectory commands\n        # WHY: Desired positions come from higher-level trajectory planners\n        self.joint_trajectory_subscriber = self.create_subscription(\n            JointState, '/joint_trajectory_commands', self.trajectory_command_callback, 10\n        )\n\n        # WHAT: Create publisher for controller state monitoring\n        # WHY: Other nodes may need to monitor controller performance\n        self.controller_state_publisher = self.create_publisher(\n            JointTrajectoryControllerState, '/controller_state', 10\n        )\n\n        # Control timer (100 Hz)\n        # WHAT: Create a timer that calls the control loop at 100 Hz\n        # WHY: Real-time control requires consistent timing\n        self.control_timer = self.create_timer(0.01, self.control_loop)\n\n        self.get_logger().info('Joint Position Controller initialized')\n\n    def joint_state_callback(self, msg: JointState):\n        \"\"\"Update current joint states from sensor feedback\"\"\"\n        # WHAT: Process incoming joint state messages and update current position, velocity, and effort values\n        # WHY: The controller needs to know the current state of each joint to compute control errors\n        for i, name in enumerate(msg.name):\n            if name in self.current_positions:\n                if i < len(msg.position):\n                    self.current_positions[name] = msg.position[i]\n                if i < len(msg.velocity):\n                    self.current_velocities[name] = msg.velocity[i]\n                if i < len(msg.effort):\n                    self.current_efforts[name] = msg.effort[i]\n\n    def trajectory_command_callback(self, msg: JointState):\n        \"\"\"Update desired joint positions from trajectory commands\"\"\"\n        # WHAT: Process incoming trajectory commands and update desired positions\n        # WHY: The controller needs to know where each joint should be positioned\n        for i, name in enumerate(msg.name):\n            if name in self.desired_positions and i < len(msg.position):\n                self.desired_positions[name] = msg.position[i]\n\n    def control_loop(self):\n        \"\"\"Main control loop executing PID control for each joint\"\"\"\n        # WHAT: This is the main control loop that runs at 100Hz\n        # WHY: Real-time control requires consistent execution at regular intervals\n        current_time = self.get_clock().now()\n        dt = (current_time - self.last_update_time).nanoseconds / 1e9\n        self.last_update_time = current_time\n\n        if dt <= 0:  # Avoid division by zero\n            # WHAT: Check for valid time delta to avoid division by zero\n            # WHY: Division by zero would cause errors in derivative calculation\n            return\n\n        # Calculate control commands for each joint\n        # WHAT: Compute PID control output for each joint\n        # WHY: Each joint needs individual control to achieve desired positions\n        for joint_name in self.joint_names:\n            # Calculate error\n            # WHAT: Compute the difference between desired and actual position\n            # WHY: Error is the fundamental input to the control algorithm\n            error = self.desired_positions[joint_name] - self.current_positions[joint_name]\n\n            # Update integral term (with anti-windup)\n            # WHAT: Accumulate error over time for the integral component\n            # WHY: The integral term helps eliminate steady-state error\n            self.integral_errors[joint_name] += error * dt\n            # Limit integral term to prevent windup\n            # WHAT: Apply limits to the integral accumulator to prevent windup\n            # WHY: Windup occurs when the integral term grows too large during saturation\n            integral_limit = 10.0\n            self.integral_errors[joint_name] = max(-integral_limit,\n                                                  min(integral_limit,\n                                                      self.integral_errors[joint_name]))\n\n            # Calculate derivative term\n            # WHAT: Compute the rate of change of error for the derivative component\n            # WHY: The derivative term provides damping to reduce oscillation\n            if dt > 0:\n                derivative = (error - self.previous_errors[joint_name]) / dt\n            else:\n                derivative = 0.0\n\n            # Store current error for next derivative calculation\n            # WHAT: Save the current error for use in the next derivative calculation\n            # WHY: Derivative calculation requires the previous error value\n            self.previous_errors[joint_name] = error\n\n            # Calculate PID output\n            # WHAT: Combine the three PID terms to get the control output\n            # WHY: The PID formula provides balanced control with proportional, integral, and derivative action\n            p_term = self.kp[joint_name] * error\n            i_term = self.ki[joint_name] * self.integral_errors[joint_name]\n            d_term = self.kd[joint_name] * derivative\n\n            effort_command = p_term + i_term + d_term\n\n            # Apply safety limits\n            # WHAT: Limit the commanded effort to safe values\n            # WHY: Protect the robot from excessive forces that could cause damage\n            effort_limit = 100.0  # Nm or appropriate unit\n            effort_command = max(-effort_limit, min(effort_limit, effort_command))\n\n            # Store commanded effort\n            # WHAT: Save the computed effort command for publishing\n            # WHY: The effort command needs to be sent to the robot's actuators\n            self.commanded_efforts[joint_name] = effort_command\n\n        # Publish effort commands\n        # WHAT: Send the computed effort commands to the robot\n        # WHY: Commands must be transmitted to the actuators for execution\n        command_msg = Float64MultiArray()\n        command_msg.data = [self.commanded_efforts[name] for name in self.joint_names]\n        self.joint_command_publisher.publish(command_msg)\n\n        # Publish controller state for monitoring\n        # WHAT: Publish controller state information for monitoring and debugging\n        # WHY: Other nodes may need to monitor controller performance and errors\n        state_msg = JointTrajectoryControllerState()\n        state_msg.header.stamp = current_time.to_msg()\n        state_msg.joint_names = self.joint_names\n        state_msg.desired.positions = [self.desired_positions[name] for name in self.joint_names]\n        state_msg.actual.positions = [self.current_positions[name] for name in self.joint_names]\n        state_msg.error.positions = [self.desired_positions[name] - self.current_positions[name]\n                                    for name in self.joint_names]\n        self.controller_state_publisher.publish(state_msg)\n\ndef main(args=None):\n    \"\"\"Main function to initialize and run the joint position controller\"\"\"\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n    controller = JointPositionController()\n\n    try:\n        # Start spinning the node to process callbacks\n        # WHAT: This starts the ROS 2 event loop, processing all callbacks\n        # WHY: Without spinning, the node wouldn't execute its timer and subscriber callbacks\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        # WHAT: This handles the case when the user interrupts the program\n        # WHY: Provides a clean way to stop the controller when needed\n        controller.get_logger().info('Shutting down joint position controller')\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dependencies"}),": ",(0,r.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,r.jsx)(n.code,{children:"sensor_msgs"}),", ",(0,r.jsx)(n.code,{children:"std_msgs"}),", ",(0,r.jsx)(n.code,{children:"control_msgs"}),", ",(0,r.jsx)(n.code,{children:"numpy"})]}),"\n",(0,r.jsx)(n.h3,{id:"advanced-control-whole-body-controller",children:"Advanced Control: Whole-Body Controller"}),"\n",(0,r.jsx)(n.p,{children:"Here's an implementation of a more advanced controller for whole-body humanoid control:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Example: Whole-Body Controller\n# WHAT: This code implements a whole-body controller for humanoid robots with multiple tasks\n# WHY: To demonstrate hierarchical control for complex humanoid behaviors\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist, Vector3, Point\nfrom std_msgs.msg import Float64MultiArray, String\nfrom builtin_interfaces.msg import Time\nimport numpy as np\nimport math\nfrom typing import Dict, List, Tuple, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass ControlTask:\n    \"\"\"Represents a control task with priority and weight\"\"\"\n    name: str\n    priority: int  # Lower number = higher priority\n    weight: float\n    target_value: float\n    current_value: float = 0.0\n\nclass WholeBodyController(Node):\n    def __init__(self):\n        super().__init__('whole_body_controller')\n\n        # Robot configuration\n        self.joint_names = [\n            'left_hip', 'left_knee', 'left_ankle', 'left_shoulder', 'left_elbow',\n            'right_hip', 'right_knee', 'right_ankle', 'right_shoulder', 'right_elbow',\n            'torso_yaw', 'torso_pitch', 'neck_yaw', 'neck_pitch'\n        ]\n\n        # Joint limits (radians)\n        self.joint_limits = {\n            name: (-math.pi, math.pi) for name in self.joint_names\n        }\n\n        # Initialize joint states\n        self.current_positions = {name: 0.0 for name in self.joint_names}\n        self.current_velocities = {name: 0.0 for name in self.joint_names}\n        self.current_efforts = {name: 0.0 for name in self.joint_names}\n        self.desired_positions = {name: 0.0 for name in self.joint_names}\n        self.commanded_torques = {name: 0.0 for name in self.joint_names}\n\n        # Control parameters\n        self.control_timestep = 0.001  # 1kHz control\n        self.gravity = 9.81  # m/s^2\n        self.robot_mass = 50.0  # kg (approximate)\n\n        # Balance control parameters\n        self.com_reference = np.array([0.0, 0.0, 0.8])  # Desired CoM position\n        self.com_threshold = 0.05  # CoM deviation threshold (m)\n\n        # Walking parameters\n        self.step_height = 0.05  # m\n        self.step_length = 0.3   # m\n        self.step_duration = 1.0 # s\n\n        # IMU data\n        self.imu_orientation = np.array([0.0, 0.0, 0.0, 1.0])  # x, y, z, w\n        self.imu_angular_velocity = np.array([0.0, 0.0, 0.0])  # x, y, z\n        self.imu_linear_acceleration = np.array([0.0, 0.0, 0.0])  # x, y, z\n\n        # Control tasks\n        self.control_tasks: List[ControlTask] = []\n        self.initialize_control_tasks()\n\n        # Publishers and subscribers\n        self.joint_command_publisher = self.create_publisher(\n            Float64MultiArray, '/effort_commands', 10\n        )\n\n        self.joint_state_subscriber = self.create_subscription(\n            JointState, '/joint_states', self.joint_state_callback, 10\n        )\n\n        self.imu_subscriber = self.create_subscription(\n            Imu, '/imu_data', self.imu_callback, 10\n        )\n\n        self.command_subscriber = self.create_subscription(\n            Twist, '/cmd_vel', self.command_callback, 10\n        )\n\n        self.status_publisher = self.create_publisher(String, '/controller_status', 10)\n\n        # Control timer (1kHz)\n        self.control_timer = self.create_timer(self.control_timestep, self.control_loop)\n\n        self.get_logger().info('Whole-Body Controller initialized')\n\n    def initialize_control_tasks(self):\n        \"\"\"Initialize the control tasks with priorities and weights\"\"\"\n        # High priority: Balance maintenance\n        self.control_tasks.append(ControlTask(\n            name='balance_maintenance',\n            priority=0,\n            weight=10.0,\n            target_value=0.0\n        ))\n\n        # Medium priority: Joint position tracking\n        self.control_tasks.append(ControlTask(\n            name='joint_position_tracking',\n            priority=1,\n            weight=5.0,\n            target_value=0.0\n        ))\n\n        # Low priority: Posture maintenance\n        self.control_tasks.append(ControlTask(\n            name='posture_maintenance',\n            priority=2,\n            weight=1.0,\n            target_value=0.0\n        ))\n\n    def joint_state_callback(self, msg: JointState):\n        \"\"\"Update current joint states from sensor feedback\"\"\"\n        for i, name in enumerate(msg.name):\n            if name in self.current_positions:\n                if i < len(msg.position):\n                    self.current_positions[name] = msg.position[i]\n                if i < len(msg.velocity):\n                    self.current_velocities[name] = msg.velocity[i]\n                if i < len(msg.effort):\n                    self.current_efforts[name] = msg.effort[i]\n\n    def imu_callback(self, msg: Imu):\n        \"\"\"Update IMU data\"\"\"\n        # Orientation (quaternion)\n        self.imu_orientation = np.array([\n            msg.orientation.x,\n            msg.orientation.y,\n            msg.orientation.z,\n            msg.orientation.w\n        ])\n\n        # Angular velocity\n        self.imu_angular_velocity = np.array([\n            msg.angular_velocity.x,\n            msg.angular_velocity.y,\n            msg.angular_velocity.z\n        ])\n\n        # Linear acceleration\n        self.imu_linear_acceleration = np.array([\n            msg.linear_acceleration.x,\n            msg.linear_acceleration.y,\n            msg.linear_acceleration.z\n        ])\n\n    def command_callback(self, msg: Twist):\n        \"\"\"Handle high-level commands\"\"\"\n        # For now, just store the command\n        # In a real implementation, this would update desired trajectories\n        pass\n\n    def calculate_center_of_mass(self) -> np.ndarray:\n        \"\"\"Calculate current center of mass position (simplified)\"\"\"\n        # This is a simplified calculation - in reality, you'd need the full URDF\n        # and mass distribution to calculate CoM accurately\n        com_x = 0.0\n        com_y = 0.0\n        com_z = 0.8  # Approximate CoM height for standing humanoid\n\n        # Add contribution from each joint based on position and estimated mass\n        for name, pos in self.current_positions.items():\n            if 'hip' in name or 'knee' in name or 'ankle' in name:\n                # Legs contribute to CoM position\n                if 'left' in name:\n                    com_y -= 0.05  # Left leg offset\n                elif 'right' in name:\n                    com_y += 0.05  # Right leg offset\n\n        return np.array([com_x, com_y, com_z])\n\n    def compute_balance_control(self) -> Dict[str, float]:\n        \"\"\"Compute balance control torques based on CoM position\"\"\"\n        current_com = self.calculate_center_of_mass()\n        com_error = current_com - self.com_reference\n\n        # Simple balance control based on CoM error\n        balance_torques = {}\n\n        # Yaw balance (left-right stability)\n        if abs(com_error[1]) > self.com_threshold:\n            # Apply corrective torques to hip joints\n            corrective_torque = -50.0 * com_error[1]  # Proportional control\n            balance_torques['left_hip'] = corrective_torque\n            balance_torques['right_hip'] = -corrective_torque\n        else:\n            balance_torques['left_hip'] = 0.0\n            balance_torques['right_hip'] = 0.0\n\n        # Pitch balance (forward-back stability)\n        if abs(com_error[0]) > self.com_threshold:\n            corrective_torque = -30.0 * com_error[0]\n            balance_torques['left_ankle'] = corrective_torque\n            balance_torques['right_ankle'] = corrective_torque\n        else:\n            balance_torques['left_ankle'] = 0.0\n            balance_torques['right_ankle'] = 0.0\n\n        return balance_torques\n\n    def compute_joint_position_control(self) -> Dict[str, float]:\n        \"\"\"Compute joint position control torques\"\"\"\n        position_torques = {}\n\n        for name in self.joint_names:\n            # Calculate position error\n            error = self.desired_positions[name] - self.current_positions[name]\n\n            # Simple PD control\n            kp = 50.0  # Position gain\n            kd = 5.0   # Velocity gain\n\n            # Calculate torque command\n            torque = kp * error - kd * self.current_velocities[name]\n\n            # Apply limits\n            torque = max(-100.0, min(100.0, torque))\n\n            position_torques[name] = torque\n\n        return position_torques\n\n    def compute_posture_control(self) -> Dict[str, float]:\n        \"\"\"Compute posture maintenance torques (return to neutral position)\"\"\"\n        neutral_positions = {\n            name: 0.0 for name in self.joint_names\n        }\n\n        # Set some default neutral positions\n        neutral_positions['left_knee'] = -0.5\n        neutral_positions['right_knee'] = -0.5\n        neutral_positions['left_ankle'] = 0.5\n        neutral_positions['right_ankle'] = 0.5\n\n        posture_torques = {}\n\n        for name in self.joint_names:\n            # Calculate error from neutral position\n            error = neutral_positions[name] - self.current_positions[name]\n\n            # Simple P control for posture\n            posture_torques[name] = 10.0 * error  # Gentle posture maintenance\n\n        return posture_torques\n\n    def hierarchical_control(self) -> Dict[str, float]:\n        \"\"\"Implement hierarchical control prioritizing tasks\"\"\"\n        # Initialize torques\n        total_torques = {name: 0.0 for name in self.joint_names}\n\n        # Sort tasks by priority (lower number = higher priority)\n        sorted_tasks = sorted(self.control_tasks, key=lambda x: x.priority)\n\n        # Apply control for each task in priority order\n        for task in sorted_tasks:\n            if task.name == 'balance_maintenance':\n                balance_torques = self.compute_balance_control()\n                for joint, torque in balance_torques.items():\n                    if joint in total_torques:\n                        total_torques[joint] += torque * task.weight\n            elif task.name == 'joint_position_tracking':\n                position_torques = self.compute_joint_position_control()\n                for joint, torque in position_torques.items():\n                    if joint in total_torques:\n                        total_torques[joint] += torque * task.weight\n            elif task.name == 'posture_maintenance':\n                posture_torques = self.compute_posture_control()\n                for joint, torque in posture_torques.items():\n                    if joint in total_torques:\n                        total_torques[joint] += torque * task.weight\n\n        return total_torques\n\n    def control_loop(self):\n        \"\"\"Main control loop implementing whole-body control\"\"\"\n        # Compute control commands using hierarchical approach\n        commanded_torques = self.hierarchical_control()\n\n        # Apply commanded torques to joints\n        for joint_name in self.joint_names:\n            self.commanded_torques[joint_name] = commanded_torques.get(joint_name, 0.0)\n\n        # Publish torque commands\n        command_msg = Float64MultiArray()\n        command_msg.data = [self.commanded_torques[name] for name in self.joint_names]\n        self.joint_command_publisher.publish(command_msg)\n\n        # Publish status\n        status_msg = String()\n        current_com = self.calculate_center_of_mass()\n        status_msg.data = f\"CoM: [{current_com[0]:.3f}, {current_com[1]:.3f}, {current_com[2]:.3f}]\"\n        self.status_publisher.publish(status_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    controller = WholeBodyController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        controller.get_logger().info('Shutting down whole-body controller')\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dependencies"}),": ",(0,r.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,r.jsx)(n.code,{children:"sensor_msgs"}),", ",(0,r.jsx)(n.code,{children:"geometry_msgs"}),", ",(0,r.jsx)(n.code,{children:"std_msgs"}),", ",(0,r.jsx)(n.code,{children:"numpy"})]}),"\n",(0,r.jsx)(n.h3,{id:"safety-and-error-handling-controller",children:"Safety and Error Handling Controller"}),"\n",(0,r.jsx)(n.p,{children:"Here's an implementation of a safety controller that monitors the system and implements protective measures:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Example: Safety and Error Handling Controller\n# WHAT: This code implements a safety monitoring system for humanoid robot control\n# WHY: To ensure safe operation with error detection, recovery, and emergency procedures\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu, Temperature\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import Bool, String, Float64\nfrom builtin_interfaces.msg import Time\nimport numpy as np\nimport math\nfrom enum import Enum\nfrom typing import Dict, List, Optional\nimport time\n\nclass SafetyState(Enum):\n    """Safety system states"""\n    OPERATIONAL = "operational"\n    WARNING = "warning"\n    ERROR = "error"\n    EMERGENCY_STOP = "emergency_stop"\n    RECOVERY = "recovery"\n\nclass SafetyController(Node):\n    def __init__(self):\n        super().__init__(\'safety_controller\')\n\n        # Safety parameters\n        self.joint_temp_limits = {\n            \'hip\': 70.0,    # degrees Celsius\n            \'knee\': 70.0,\n            \'ankle\': 70.0,\n            \'shoulder\': 70.0,\n            \'elbow\': 70.0\n        }\n\n        self.imu_thresholds = {\n            \'roll_limit\': math.radians(30),    # radians\n            \'pitch_limit\': math.radians(30),   # radians\n            \'angular_vel_limit\': math.radians(5)  # rad/s\n        }\n\n        self.joint_effort_limits = {\n            \'hip\': 100.0,    # Nm\n            \'knee\': 80.0,\n            \'ankle\': 60.0,\n            \'shoulder\': 50.0,\n            \'elbow\': 30.0\n        }\n\n        # Joint state tracking\n        self.joint_positions = {}\n        self.joint_velocities = {}\n        self.joint_efforts = {}\n        self.joint_temperatures = {}\n\n        # IMU data\n        self.imu_roll = 0.0\n        self.imu_pitch = 0.0\n        self.imu_yaw = 0.0\n        self.imu_angular_vel = np.array([0.0, 0.0, 0.0])\n\n        # System state\n        self.safety_state = SafetyState.OPERATIONAL\n        self.last_error_time = None\n        self.recovery_attempts = 0\n        self.max_recovery_attempts = 3\n\n        # Publishers and subscribers\n        self.emergency_stop_publisher = self.create_publisher(Bool, \'/emergency_stop\', 10)\n        self.safety_status_publisher = self.create_publisher(String, \'/safety_status\', 10)\n        self.error_publisher = self.create_publisher(String, \'/error_report\', 10)\n\n        self.joint_state_subscriber = self.create_subscription(\n            JointState, \'/joint_states\', self.joint_state_callback, 10\n        )\n\n        self.joint_temp_subscriber = self.create_subscription(\n            Temperature, \'/joint_temperatures\', self.joint_temp_callback, 10\n        )\n\n        self.imu_subscriber = self.create_subscription(\n            Imu, \'/imu_data\', self.imu_callback, 10\n        )\n\n        self.reset_subscriber = self.create_subscription(\n            Bool, \'/reset_safety\', self.reset_callback, 10\n        )\n\n        # Safety monitoring timer (10Hz)\n        self.safety_timer = self.create_timer(0.1, self.safety_check)\n\n        # Emergency stop timer (for periodic publishing during emergency)\n        self.emergency_timer = self.create_timer(0.1, self.emergency_publisher)\n\n        # Initialize as operational\n        self.publish_safety_status()\n        self.get_logger().info(\'Safety Controller initialized\')\n\n    def joint_state_callback(self, msg: JointState):\n        """Process joint state messages"""\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                self.joint_positions[name] = msg.position[i]\n            if i < len(msg.velocity):\n                self.joint_velocities[name] = msg.velocity[i]\n            if i < len(msg.effort):\n                self.joint_efforts[name] = msg.effort[i]\n\n    def joint_temp_callback(self, msg: Temperature):\n        """Process joint temperature messages"""\n        # This would typically come from a separate temperature topic\n        # For this example, we\'ll simulate it based on joint effort\n        for joint_name, effort in self.joint_efforts.items():\n            # Simulate temperature based on effort (simplified model)\n            base_temp = 25.0  # Base temperature\n            temp_rise = abs(effort) * 0.1  # Simplified heating model\n            self.joint_temperatures[joint_name] = base_temp + temp_rise\n\n    def imu_callback(self, msg: Imu):\n        """Process IMU data"""\n        # Convert quaternion to roll/pitch/yaw\n        x = msg.orientation.x\n        y = msg.orientation.y\n        z = msg.orientation.z\n        w = msg.orientation.w\n\n        # Simplified conversion (for small yaw angles)\n        self.imu_roll = math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y))\n        self.imu_pitch = math.asin(2 * (w * y - z * x))\n        self.imu_yaw = math.atan2(2 * (w * z + x * y), 1 - 2 * (y * y + z * z))\n\n        # Store angular velocity\n        self.imu_angular_vel = np.array([\n            msg.angular_velocity.x,\n            msg.angular_velocity.y,\n            msg.angular_velocity.z\n        ])\n\n    def reset_callback(self, msg: Bool):\n        """Handle safety system reset commands"""\n        if msg.data and self.safety_state != SafetyState.OPERATIONAL:\n            self.get_logger().info(\'Safety system reset command received\')\n            self.safety_state = SafetyState.OPERATIONAL\n            self.recovery_attempts = 0\n            self.publish_safety_status()\n\n    def check_joint_safety(self) -> List[str]:\n        """Check joint safety conditions"""\n        errors = []\n\n        for joint_name, effort in self.joint_efforts.items():\n            # Check effort limits\n            joint_type = self.get_joint_type(joint_name)\n            max_effort = self.joint_effort_limits.get(joint_type, 100.0)\n\n            if abs(effort) > max_effort:\n                errors.append(f"Joint {joint_name} effort limit exceeded: {effort:.2f} > {max_effort}")\n\n            # Check temperature\n            temp = self.joint_temperatures.get(joint_name, 25.0)\n            max_temp = self.joint_temp_limits.get(joint_type, 70.0)\n\n            if temp > max_temp:\n                errors.append(f"Joint {joint_name} temperature limit exceeded: {temp:.2f} > {max_temp}")\n\n            # Check velocity limits (optional safety check)\n            vel = self.joint_velocities.get(joint_name, 0.0)\n            max_vel = 5.0  # rad/s (example limit)\n\n            if abs(vel) > max_vel:\n                errors.append(f"Joint {joint_name} velocity limit exceeded: {vel:.2f} > {max_vel}")\n\n        return errors\n\n    def check_balance_safety(self) -> List[str]:\n        """Check balance and orientation safety"""\n        errors = []\n\n        # Check orientation limits\n        if abs(self.imu_roll) > self.imu_thresholds[\'roll_limit\']:\n            errors.append(f"Roll angle limit exceeded: {math.degrees(self.imu_roll):.2f} > {math.degrees(self.imu_thresholds[\'roll_limit\']):.2f}")\n\n        if abs(self.imu_pitch) > self.imu_thresholds[\'pitch_limit\']:\n            errors.append(f"Pitch angle limit exceeded: {math.degrees(self.imu_pitch):.2f} > {math.degrees(self.imu_thresholds[\'pitch_limit\']):.2f}")\n\n        # Check angular velocity limits\n        ang_vel_norm = np.linalg.norm(self.imu_angular_vel)\n        if ang_vel_norm > self.imu_thresholds[\'angular_vel_limit\']:\n            errors.append(f"Angular velocity limit exceeded: {ang_vel_norm:.2f} > {self.imu_thresholds[\'angular_vel_limit\']:.2f}")\n\n        return errors\n\n    def get_joint_type(self, joint_name: str) -> str:\n        """Determine joint type from name"""\n        if \'hip\' in joint_name:\n            return \'hip\'\n        elif \'knee\' in joint_name:\n            return \'knee\'\n        elif \'ankle\' in joint_name:\n            return \'ankle\'\n        elif \'shoulder\' in joint_name:\n            return \'shoulder\'\n        elif \'elbow\' in joint_name:\n            return \'elbow\'\n        else:\n            return \'hip\'  # default\n\n    def safety_check(self):\n        """Main safety monitoring function"""\n        # Check all safety conditions\n        joint_errors = self.check_joint_safety()\n        balance_errors = self.check_balance_safety()\n\n        all_errors = joint_errors + balance_errors\n\n        # Update safety state based on errors\n        if all_errors:\n            # Log all errors\n            for error in all_errors:\n                self.get_logger().warning(error)\n\n            # Publish error report\n            error_msg = String()\n            error_msg.data = "; ".join(all_errors)\n            self.error_publisher.publish(error_msg)\n\n            # Determine new state based on error severity\n            has_critical_error = any(\n                "temperature" in err or "angular velocity" in err\n                for err in all_errors\n            )\n\n            if has_critical_error:\n                if self.safety_state != SafetyState.EMERGENCY_STOP:\n                    self.last_error_time = time.time()\n                    self.safety_state = SafetyState.EMERGENCY_STOP\n                    self.get_logger().error(\'CRITICAL ERROR - Emergency stop activated\')\n            else:\n                if self.safety_state == SafetyState.OPERATIONAL:\n                    self.safety_state = SafetyState.WARNING\n                    self.get_logger().warning(\'Safety warnings detected\')\n        else:\n            # No errors, check if we can return to operational\n            if self.safety_state == SafetyState.WARNING:\n                self.safety_state = SafetyState.OPERATIONAL\n                self.get_logger().info(\'Safety conditions normalized\')\n\n        # Handle recovery logic\n        if self.safety_state == SafetyState.EMERGENCY_STOP:\n            if self.recovery_attempts < self.max_recovery_attempts:\n                # Attempt recovery after a delay\n                if (time.time() - self.last_error_time) > 5.0:  # 5 second delay\n                    self.safety_state = SafetyState.RECOVERY\n                    self.get_logger().info(f\'Attempting recovery (attempt {self.recovery_attempts + 1})\')\n                    self.recovery_attempts += 1\n            else:\n                self.get_logger().error(\'Maximum recovery attempts reached. Manual reset required.\')\n\n        # Publish safety status\n        self.publish_safety_status()\n\n    def publish_safety_status(self):\n        """Publish current safety status"""\n        status_msg = String()\n        status_msg.data = f"State: {self.safety_state.value}"\n\n        if self.safety_state == SafetyState.EMERGENCY_STOP:\n            status_msg.data += f" | Recovery attempts: {self.recovery_attempts}/{self.max_recovery_attempts}"\n\n        self.safety_status_publisher.publish(status_msg)\n\n    def emergency_publisher(self):\n        """Publish emergency stop commands when in emergency state"""\n        if self.safety_state == SafetyState.EMERGENCY_STOP:\n            stop_msg = Bool()\n            stop_msg.data = True\n            self.emergency_stop_publisher.publish(stop_msg)\n        else:\n            # When not in emergency, publish false to allow normal operation\n            if self.safety_state != SafetyState.RECOVERY:\n                stop_msg = Bool()\n                stop_msg.data = False\n                self.emergency_stop_publisher.publish(stop_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    safety_controller = SafetyController()\n\n    try:\n        rclpy.spin(safety_controller)\n    except KeyboardInterrupt:\n        safety_controller.get_logger().info(\'Shutting down safety controller\')\n    finally:\n        safety_controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dependencies"}),": ",(0,r.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,r.jsx)(n.code,{children:"sensor_msgs"}),", ",(0,r.jsx)(n.code,{children:"geometry_msgs"}),", ",(0,r.jsx)(n.code,{children:"std_msgs"}),", ",(0,r.jsx)(n.code,{children:"numpy"})]}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.h3,{id:"example-walking-controller-with-trajectory-generation",children:"Example: Walking Controller with Trajectory Generation"}),"\n",(0,r.jsx)(n.p,{children:"Here's a complete example that combines trajectory generation with walking control:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Example: Walking Controller with Trajectory Generation\n# WHAT: This code implements a walking controller with foot trajectory generation\n# WHY: To demonstrate how to generate and execute walking patterns for humanoid robots\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist, Point, Vector3\nfrom std_msgs.msg import Float64MultiArray, String, Bool\nfrom builtin_interfaces.msg import Time\nimport numpy as np\nimport math\nfrom typing import Dict, List, Tuple\nfrom enum import Enum\n\nclass WalkingState(Enum):\n    """Walking controller states"""\n    IDLE = "idle"\n    STARTING = "starting"\n    WALKING = "walking"\n    STOPPING = "stopping"\n    BALANCING = "balancing"\n\nclass WalkingController(Node):\n    def __init__(self):\n        super().__init__(\'walking_controller\')\n\n        # Walking parameters\n        self.step_height = 0.05  # m\n        self.step_length = 0.3   # m\n        self.step_duration = 1.0 # s\n        self.zmp_margin = 0.02   # Zero Moment Point safety margin (m)\n\n        # Robot configuration\n        self.joint_names = [\n            \'left_hip\', \'left_knee\', \'left_ankle\',\n            \'right_hip\', \'right_knee\', \'right_ankle\'\n        ]\n\n        # Walking state\n        self.walking_state = WalkingState.IDLE\n        self.walk_velocity = Twist()  # Linear and angular velocity commands\n        self.support_foot = \'left\'  # Which foot is currently supporting weight\n        self.swing_foot = \'right\'   # Which foot is swinging\n        self.step_progress = 0.0    # Progress in current step (0.0 to 1.0)\n        self.step_count = 0         # Number of completed steps\n\n        # Joint states\n        self.current_positions = {name: 0.0 for name in self.joint_names}\n        self.desired_positions = {name: 0.0 for name in self.joint_names}\n        self.commanded_torques = {name: 0.0 for name in self.joint_names}\n\n        # IMU data for balance\n        self.roll = 0.0\n        self.pitch = 0.0\n        self.yaw = 0.0\n\n        # Publishers and subscribers\n        self.joint_command_publisher = self.create_publisher(\n            Float64MultiArray, \'/effort_commands\', 10\n        )\n\n        self.joint_state_subscriber = self.create_subscription(\n            JointState, \'/joint_states\', self.joint_state_callback, 10\n        )\n\n        self.imu_subscriber = self.create_subscription(\n            Imu, \'/imu_data\', self.imu_callback, 10\n        )\n\n        self.cmd_vel_subscriber = self.create_subscription(\n            Twist, \'/cmd_vel\', self.cmd_vel_callback, 10\n        )\n\n        self.status_publisher = self.create_publisher(String, \'/walking_status\', 10)\n        self.step_publisher = self.create_publisher(Bool, \'/step_event\', 10)\n\n        # Control timer (200Hz for walking control)\n        self.control_timer = self.create_timer(0.005, self.control_loop)\n\n        self.get_logger().info(\'Walking Controller initialized\')\n\n    def joint_state_callback(self, msg: JointState):\n        """Update current joint states"""\n        for i, name in enumerate(msg.name):\n            if name in self.current_positions and i < len(msg.position):\n                self.current_positions[name] = msg.position[i]\n\n    def imu_callback(self, msg: Imu):\n        """Update IMU data"""\n        # Convert quaternion to roll/pitch/yaw (simplified)\n        x = msg.orientation.x\n        y = msg.orientation.y\n        z = msg.orientation.z\n        w = msg.orientation.w\n\n        self.roll = math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y))\n        self.pitch = math.asin(2 * (w * y - z * x))\n\n    def cmd_vel_callback(self, msg: Twist):\n        """Handle velocity commands"""\n        self.walk_velocity = msg\n\n        # Change walking state based on command\n        if abs(msg.linear.x) > 0.01 or abs(msg.angular.z) > 0.01:\n            if self.walking_state == WalkingState.IDLE:\n                self.walking_state = WalkingState.STARTING\n        else:\n            if self.walking_state == WalkingState.WALKING:\n                self.walking_state = WalkingState.STOPPING\n\n    def generate_foot_trajectory(self, progress: float, foot: str) -> Tuple[float, float, float]:\n        """Generate 3D trajectory for a foot during walking"""\n        # Simplified trajectory generation\n        # X: Forward/backward movement\n        x = progress * self.step_length if foot == self.swing_foot else 0.0\n\n        # Y: Lateral movement (for balance)\n        y = -0.1 if foot == \'left\' else 0.1  # Fixed stance width\n\n        # Z: Vertical movement (foot lifting)\n        if foot == self.swing_foot:\n            # Lift foot in a parabolic trajectory\n            lift_factor = math.sin(math.pi * progress)\n            z = self.step_height * lift_factor\n        else:\n            # Support foot stays on ground\n            z = 0.0\n\n        return x, y, z\n\n    def compute_inverse_kinematics(self, target_pos: Tuple[float, float, float], foot: str) -> Dict[str, float]:\n        """Compute inverse kinematics for 3-DOF leg to reach target position"""\n        x, y, z = target_pos\n\n        # Simplified 3-DOF inverse kinematics for humanoid leg\n        # This is a basic implementation - real robots would use more sophisticated IK\n\n        # Calculate leg length requirements\n        hip_to_foot_xz = math.sqrt(x*x + z*z)  # Horizontal distance from hip to foot\n        leg_length = 0.4  # Simplified leg length (thigh + shin)\n\n        # Check if target is reachable\n        if hip_to_foot_xz > leg_length:\n            # Scale down to reachable position\n            scale = leg_length / hip_to_foot_xz\n            x *= scale\n            z *= scale\n\n        # Calculate knee angle (using law of cosines)\n        # For a simplified 2D leg (sagittal plane)\n        d = math.sqrt(x*x + z*z)  # Distance from hip to target\n\n        if d > 0.01:  # Avoid division by zero\n            # Knee angle calculation\n            cos_knee = (0.2*0.2 + 0.2*0.2 - d*d) / (2 * 0.2 * 0.2)  # Assuming thigh=shin=0.2m\n            cos_knee = max(-1.0, min(1.0, cos_knee))  # Clamp to valid range\n            knee_angle = math.pi - math.acos(cos_knee)\n\n            # Hip angles\n            hip_pitch = math.atan2(x, z) - math.asin((0.2 * math.sin(math.pi - knee_angle)) / d)\n            hip_roll = math.atan2(y, max(abs(x), 0.01)) * 0.5  # Simplified lateral adjustment\n        else:\n            # Default standing position\n            knee_angle = 0.0\n            hip_pitch = 0.0\n            hip_roll = 0.0\n\n        # Ankle angle for foot level\n        ankle_angle = -hip_pitch  # Simplified compensation\n\n        # Create joint angle dictionary based on foot\n        if foot == \'left\':\n            return {\n                \'left_hip\': hip_roll,      # Simplified - would be hip_yaw, hip_roll, hip_pitch\n                \'left_knee\': knee_angle,\n                \'left_ankle\': ankle_angle\n            }\n        else:  # right foot\n            return {\n                \'right_hip\': -hip_roll,    # Opposite for right leg\n                \'right_knee\': knee_angle,\n                \'right_ankle\': ankle_angle\n            }\n\n    def balance_control(self) -> Dict[str, float]:\n        """Compute balance control adjustments based on IMU data"""\n        balance_adjustments = {}\n\n        # Simple balance control based on roll/pitch\n        max_adjustment = 0.1  # rad\n\n        # Adjust ankle angles to counteract roll\n        roll_correction = -self.roll * 2.0  # Gain for roll correction\n        roll_correction = max(-max_adjustment, min(max_adjustment, roll_correction))\n\n        # Adjust hip angles to counteract pitch\n        pitch_correction = -self.pitch * 1.5  # Gain for pitch correction\n        pitch_correction = max(-max_adjustment, min(max_adjustment, pitch_correction))\n\n        balance_adjustments.update({\n            \'left_ankle\': roll_correction,\n            \'right_ankle\': -roll_correction,  # Opposite for right foot\n            \'left_hip\': pitch_correction,\n            \'right_hip\': pitch_correction\n        })\n\n        return balance_adjustments\n\n    def control_loop(self):\n        """Main walking control loop"""\n        # Update walking state machine\n        self.update_walking_state()\n\n        # Generate walking pattern based on current state\n        if self.walking_state in [WalkingState.WALKING, WalkingState.STARTING]:\n            self.execute_walking_step()\n        elif self.walking_state == WalkingState.BALANCING:\n            self.execute_balancing()\n        else:\n            # In IDLE, STOPPING states - maintain standing position\n            self.maintain_standing_position()\n\n        # Apply balance corrections\n        balance_adjustments = self.balance_control()\n\n        # Calculate final joint positions\n        final_positions = {}\n        for joint in self.joint_names:\n            base_pos = self.desired_positions[joint]\n            adjustment = balance_adjustments.get(joint, 0.0)\n            final_positions[joint] = base_pos + adjustment\n\n        # Publish commands\n        command_msg = Float64MultiArray()\n        command_msg.data = [final_positions[name] for name in self.joint_names]\n        self.joint_command_publisher.publish(command_msg)\n\n        # Publish status\n        status_msg = String()\n        status_msg.data = f"State: {self.walking_state.value}, Progress: {self.step_progress:.2f}, Support: {self.support_foot}"\n        self.status_publisher.publish(status_msg)\n\n    def update_walking_state(self):\n        """Update the walking state machine"""\n        if self.walking_state == WalkingState.STARTING:\n            # Transition to walking after initial setup\n            self.walking_state = WalkingState.WALKING\n            self.step_progress = 0.0\n        elif self.walking_state == WalkingState.WALKING:\n            # Check if we need to transition to stopping\n            if abs(self.walk_velocity.linear.x) < 0.01 and abs(self.walk_velocity.angular.z) < 0.01:\n                if self.step_progress > 0.8:  # Wait for step completion\n                    self.walking_state = WalkingState.STOPPING\n        elif self.walking_state == WalkingState.STOPPING:\n            # Check if stopping is complete\n            if self.step_progress >= 1.0:\n                self.walking_state = WalkingState.IDLE\n        elif self.walking_state == WalkingState.IDLE:\n            # Check if we need to start walking\n            if abs(self.walk_velocity.linear.x) > 0.01 or abs(self.walk_velocity.angular.z) > 0.01:\n                self.walking_state = WalkingState.STARTING\n\n    def execute_walking_step(self):\n        """Execute a single walking step"""\n        # Update step progress\n        step_increment = 0.01  # Adjust based on control frequency and desired step duration\n        self.step_progress += step_increment / self.step_duration\n\n        if self.step_progress >= 1.0:\n            # Step completed, switch support foot\n            self.support_foot, self.swing_foot = self.swing_foot, self.support_foot\n            self.step_progress = 0.0\n            self.step_count += 1\n\n            # Publish step event\n            step_msg = Bool()\n            step_msg.data = True\n            self.step_publisher.publish(step_msg)\n\n        # Generate trajectories for both feet\n        support_pos = self.generate_foot_trajectory(0.0, self.support_foot)  # Support foot stays put\n        swing_pos = self.generate_foot_trajectory(self.step_progress, self.swing_foot)  # Swing foot moves\n\n        # Compute joint angles for swing foot\n        swing_angles = self.compute_inverse_kinematics(swing_pos, self.swing_foot)\n\n        # For support foot, maintain stable position or slight adjustment\n        support_angles = self.compute_inverse_kinematics(support_pos, self.support_foot)\n\n        # Update desired positions\n        for joint, angle in swing_angles.items():\n            self.desired_positions[joint] = angle\n\n        for joint, angle in support_angles.items():\n            self.desired_positions[joint] = angle\n\n    def execute_balancing(self):\n        """Execute balancing behavior"""\n        # For now, just maintain current position with balance adjustments\n        pass\n\n    def maintain_standing_position(self):\n        """Maintain a standing position"""\n        standing_angles = {\n            \'left_hip\': 0.0,\n            \'left_knee\': -0.5,  # Bent knee for stability\n            \'left_ankle\': 0.5,   # Compensate for bent knee\n            \'right_hip\': 0.0,\n            \'right_knee\': -0.5,\n            \'right_ankle\': 0.5\n        }\n\n        for joint, angle in standing_angles.items():\n            self.desired_positions[joint] = angle\n\ndef main(args=None):\n    rclpy.init(args=args)\n    walking_controller = WalkingController()\n\n    try:\n        rclpy.spin(walking_controller)\n    except KeyboardInterrupt:\n        walking_controller.get_logger().info(\'Shutting down walking controller\')\n    finally:\n        walking_controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dependencies"}),": ",(0,r.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,r.jsx)(n.code,{children:"sensor_msgs"}),", ",(0,r.jsx)(n.code,{children:"geometry_msgs"}),", ",(0,r.jsx)(n.code,{children:"std_msgs"}),", ",(0,r.jsx)(n.code,{children:"numpy"})]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"In this chapter, we've explored ROS 2 control architecture for humanoid robots:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Basic Joint Control"}),": PID controllers for individual joints with safety limits"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Whole-Body Control"}),": Hierarchical control systems managing multiple tasks simultaneously"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safety Systems"}),": Error detection, emergency procedures, and recovery mechanisms"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Walking Control"}),": Trajectory generation and gait control for bipedal locomotion"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The control architecture forms the backbone of humanoid robot operation, requiring careful consideration of stability, safety, and coordination between multiple subsystems. Proper control design ensures reliable and safe robot operation."}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsx)(n.h3,{id:"conceptual",children:"Conceptual"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Explain the differences between position, velocity, and effort control in humanoid robots. When would you use each type?"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"logical",children:"Logical"}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"Design a control architecture for a humanoid robot that can walk, maintain balance, and manipulate objects simultaneously. How would you prioritize these tasks and handle conflicts?"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsx)(n.li,{children:"Implement a Python controller that uses inverse kinematics to make a humanoid robot arm follow a Cartesian trajectory while avoiding joint limits. Include proper error handling for unreachable positions."}),"\n"]})]})}function f(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},8453(e,n,t){t.d(n,{R:()=>s,x:()=>a});var o=t(6540);const r={},i=o.createContext(r);function s(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);