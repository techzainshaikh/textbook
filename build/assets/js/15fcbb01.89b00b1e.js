"use strict";(globalThis.webpackChunkphysical_ai_book_humanoid=globalThis.webpackChunkphysical_ai_book_humanoid||[]).push([[249],{4752(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"module-1-ros2/chapter-1-nodes-topics-services","title":"Chapter 1 - Nodes, Topics, Services, Actions","description":"Understanding ROS 2 communication patterns for humanoid robotics","source":"@site/docs/module-1-ros2/chapter-1-nodes-topics-services.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-1-nodes-topics-services","permalink":"/docs/module-1-ros2/chapter-1-nodes-topics-services","draft":false,"unlisted":false,"editUrl":"https://github.com/Panaversity/physical_ai_book_humanoid/tree/main/docs/module-1-ros2/chapter-1-nodes-topics-services.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Chapter 1 - Nodes, Topics, Services, Actions","description":"Understanding ROS 2 communication patterns for humanoid robotics","keywords":["ros2","nodes","topics","services","actions","communication"]},"sidebar":"tutorialSidebar","previous":{"title":"Module 1 - The Robotic Nervous System (ROS 2)","permalink":"/docs/module-1-ros2/intro"},"next":{"title":"Chapter 1 - Exercises","permalink":"/docs/module-1-ros2/chapter-1-exercises"}}');var t=i(4848),o=i(8453);const r={sidebar_position:2,title:"Chapter 1 - Nodes, Topics, Services, Actions",description:"Understanding ROS 2 communication patterns for humanoid robotics",keywords:["ros2","nodes","topics","services","actions","communication"]},a="Chapter 1 - Nodes, Topics, Services, Actions",c={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Nodes",id:"nodes",level:3},{value:"Topics and Publish-Subscribe Communication",id:"topics-and-publish-subscribe-communication",level:3},{value:"Services and Request-Response Communication",id:"services-and-request-response-communication",level:3},{value:"Actions",id:"actions",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Creating a Basic ROS 2 Node",id:"creating-a-basic-ros-2-node",level:3},{value:"Creating a Publisher-Subscriber Example",id:"creating-a-publisher-subscriber-example",level:3},{value:"Examples",id:"examples",level:2},{value:"Example 1: Service for Robot Activation",id:"example-1-service-for-robot-activation",level:3},{value:"Example 2: Action for Navigation",id:"example-2-action-for-navigation",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Conceptual",id:"conceptual",level:3},{value:"Logical",id:"logical",level:3},{value:"Implementation",id:"implementation-1",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-1---nodes-topics-services-actions",children:"Chapter 1 - Nodes, Topics, Services, Actions"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Explain the fundamental ROS 2 communication patterns: nodes, topics, services, and actions"}),"\n",(0,t.jsx)(n.li,{children:"Implement basic ROS 2 nodes for humanoid robot components"}),"\n",(0,t.jsx)(n.li,{children:"Create publishers and subscribers for sensor and actuator data"}),"\n",(0,t.jsx)(n.li,{children:"Design services for synchronous robot operations"}),"\n",(0,t.jsx)(n.li,{children:"Compare the use cases for each communication pattern in humanoid robotics"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsx)(n.p,{children:"Before starting this chapter, students should have:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Basic Python programming knowledge"}),"\n",(0,t.jsx)(n.li,{children:"Understanding of object-oriented programming concepts"}),"\n",(0,t.jsx)(n.li,{children:"Familiarity with the ROS 2 installation and basic setup"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(n.h3,{id:"nodes",children:"Nodes"}),"\n",(0,t.jsx)(n.p,{children:"A node is a process that performs computation. In ROS 2, nodes are the fundamental building blocks of a robotic application. Each node typically performs a specific function within the larger robot system."}),"\n",(0,t.jsx)(n.p,{children:"In humanoid robotics, nodes might represent:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Sensor drivers (IMU, cameras, LiDAR)"}),"\n",(0,t.jsx)(n.li,{children:"Actuator controllers (joint position, velocity, effort)"}),"\n",(0,t.jsx)(n.li,{children:"Perception systems (object detection, SLAM)"}),"\n",(0,t.jsx)(n.li,{children:"Control algorithms (walking, balance, manipulation)"}),"\n",(0,t.jsx)(n.li,{children:"High-level planning (path planning, task planning)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"topics-and-publish-subscribe-communication",children:"Topics and Publish-Subscribe Communication"}),"\n",(0,t.jsx)(n.p,{children:"Topics enable asynchronous, many-to-many communication using a publish-subscribe pattern. Publishers send messages to topics, and subscribers receive messages from topics. This decouples the publisher from the subscriber, allowing for flexible system design."}),"\n",(0,t.jsx)(n.p,{children:"In humanoid robotics, topics are commonly used for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Sensor data streams (IMU readings, camera images)"}),"\n",(0,t.jsx)(n.li,{children:"Robot state information (joint positions, velocities)"}),"\n",(0,t.jsx)(n.li,{children:"Control commands (desired joint positions)"}),"\n",(0,t.jsx)(n.li,{children:"Perception results (detected objects, obstacles)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"services-and-request-response-communication",children:"Services and Request-Response Communication"}),"\n",(0,t.jsx)(n.p,{children:"Services enable synchronous, request-response communication between nodes. A client sends a request to a service, and the service sends back a response. This is useful for operations that require a definitive result."}),"\n",(0,t.jsx)(n.p,{children:"In humanoid robotics, services are commonly used for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Robot activation/deactivation"}),"\n",(0,t.jsx)(n.li,{children:"Parameter configuration"}),"\n",(0,t.jsx)(n.li,{children:"Calibration procedures"}),"\n",(0,t.jsx)(n.li,{children:"Task execution confirmation"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"actions",children:"Actions"}),"\n",(0,t.jsx)(n.p,{children:"Actions provide a way to handle long-running tasks with feedback. They combine the features of services and topics, allowing for goal requests, feedback during execution, and final results."}),"\n",(0,t.jsx)(n.p,{children:"In humanoid robotics, actions are commonly used for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Navigation to a specific location"}),"\n",(0,t.jsx)(n.li,{children:"Manipulation tasks"}),"\n",(0,t.jsx)(n.li,{children:"Walking or locomotion sequences"}),"\n",(0,t.jsx)(n.li,{children:"Complex multi-step operations"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"creating-a-basic-ros-2-node",children:"Creating a Basic ROS 2 Node"}),"\n",(0,t.jsx)(n.p,{children:"Let's create a simple ROS 2 node that represents a humanoid robot's head controller:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Example: Humanoid Head Controller Node\n# WHAT: This code creates a ROS 2 node that controls a humanoid robot's head movements\n# WHY: To demonstrate basic ROS 2 node structure and communication patterns\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float32\nfrom sensor_msgs.msg import JointState\nfrom builtin_interfaces.msg import Duration\n\nclass HeadController(Node):\n    def __init__(self):\n        super().__init__('head_controller')\n\n        # Publisher for head position commands\n        self.head_cmd_publisher = self.create_publisher(\n            Float32,\n            'head_position_cmd',\n            10\n        )\n\n        # Subscriber for joint states\n        self.joint_state_subscriber = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        # Timer to periodically send commands\n        self.timer = self.create_timer(0.1, self.timer_callback)  # 10Hz\n\n        self.get_logger().info('Head Controller node initialized')\n\n    def joint_state_callback(self, msg):\n        # Process joint state messages\n        head_position = None\n        for name, position in zip(msg.name, msg.position):\n            if name == 'head_joint':\n                head_position = position\n                break\n\n        if head_position is not None:\n            self.get_logger().info(f'Current head position: {head_position}')\n\n    def timer_callback(self):\n        # Send a head position command (example: move to 0.5 radians)\n        cmd_msg = Float32()\n        cmd_msg.data = 0.5\n        self.head_cmd_publisher.publish(cmd_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    head_controller = HeadController()\n\n    try:\n        rclpy.spin(head_controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        head_controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dependencies"}),": ",(0,t.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,t.jsx)(n.code,{children:"std_msgs"}),", ",(0,t.jsx)(n.code,{children:"sensor_msgs"})]}),"\n",(0,t.jsx)(n.h3,{id:"creating-a-publisher-subscriber-example",children:"Creating a Publisher-Subscriber Example"}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of a publisher that simulates IMU sensor data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Example: IMU Sensor Publisher\n# WHAT: This code creates a ROS 2 publisher node that simulates IMU sensor data\n# WHY: To demonstrate the publish-subscribe communication pattern for sensor data\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu\nimport math\nimport time\n\nclass ImuSensorPublisher(Node):\n    def __init__(self):\n        super().__init__('imu_sensor_publisher')\n        self.publisher = self.create_publisher(Imu, 'imu_data', 10)\n\n        # Timer to publish IMU data at 50Hz\n        self.timer = self.create_timer(0.02, self.publish_imu_data)\n\n        self.get_logger().info('IMU Sensor Publisher initialized')\n        self.time_offset = time.time()\n\n    def publish_imu_data(self):\n        msg = Imu()\n\n        # Set header\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'imu_link'\n\n        # Simulate some realistic IMU data\n        current_time = time.time() - self.time_offset\n        msg.orientation.x = 0.0\n        msg.orientation.y = 0.1 * math.sin(current_time * 0.5)\n        msg.orientation.z = 0.0\n        msg.orientation.w = math.sqrt(1 - msg.orientation.y**2)\n\n        # Angular velocities (rad/s)\n        msg.angular_velocity.x = 0.01 * math.cos(current_time)\n        msg.angular_velocity.y = 0.02 * math.sin(current_time * 2)\n        msg.angular_velocity.z = 0.005 * math.cos(current_time * 0.7)\n\n        # Linear accelerations (m/s^2)\n        msg.linear_acceleration.x = 0.1 * math.sin(current_time * 3)\n        msg.linear_acceleration.y = 9.81 + 0.2 * math.cos(current_time * 2)  # gravity + movement\n        msg.linear_acceleration.z = 0.05 * math.sin(current_time * 1.5)\n\n        self.publisher.publish(msg)\n        self.get_logger().debug('Published IMU data')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    imu_publisher = ImuSensorPublisher()\n\n    try:\n        rclpy.spin(imu_publisher)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        imu_publisher.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dependencies"}),": ",(0,t.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,t.jsx)(n.code,{children:"sensor_msgs"})]}),"\n",(0,t.jsx)(n.p,{children:"And here's a corresponding subscriber:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Example: IMU Data Subscriber\n# WHAT: This code creates a ROS 2 subscriber node that processes IMU sensor data\n# WHY: To demonstrate the publish-subscribe communication pattern for sensor data processing\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu\nimport numpy as np\n\nclass ImuDataProcessor(Node):\n    def __init__(self):\n        super().__init__('imu_data_processor')\n\n        # Subscribe to IMU data\n        self.subscription = self.create_subscription(\n            Imu,\n            'imu_data',\n            self.imu_callback,\n            10\n        )\n\n        self.get_logger().info('IMU Data Processor initialized')\n        self.roll_history = []\n        self.pitch_history = []\n\n    def imu_callback(self, msg):\n        # Extract orientation from quaternion\n        x = msg.orientation.x\n        y = msg.orientation.y\n        z = msg.orientation.z\n        w = msg.orientation.w\n\n        # Convert quaternion to roll/pitch/yaw\n        # Simplified conversion (assuming small yaw)\n        roll = math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y))\n        pitch = math.asin(2 * (w * y - z * x))\n\n        # Store in history for averaging\n        self.roll_history.append(roll)\n        self.pitch_history.append(pitch)\n\n        # Keep only last 10 values for averaging\n        if len(self.roll_history) > 10:\n            self.roll_history.pop(0)\n            self.pitch_history.pop(0)\n\n        # Calculate average\n        avg_roll = sum(self.roll_history) / len(self.roll_history)\n        avg_pitch = sum(self.pitch_history) / len(self.pitch_history)\n\n        # Log processed data\n        self.get_logger().info(\n            f'Roll: {roll:.3f} rad, Pitch: {pitch:.3f} rad, '\n            f'Avg Roll: {avg_roll:.3f} rad, Avg Pitch: {avg_pitch:.3f} rad'\n        )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    imu_processor = ImuDataProcessor()\n\n    try:\n        rclpy.spin(imu_processor)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        imu_processor.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    import math  # Added import for math functions\n    main()\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dependencies"}),": ",(0,t.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,t.jsx)(n.code,{children:"sensor_msgs"}),", ",(0,t.jsx)(n.code,{children:"numpy"})]}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.h3,{id:"example-1-service-for-robot-activation",children:"Example 1: Service for Robot Activation"}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of a service that activates the humanoid robot:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Example: Robot Activation Service\n# WHAT: This code creates a ROS 2 service that handles robot activation requests\n# WHY: To demonstrate the request-response communication pattern for robot operations\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile\nfrom example_interfaces.srv import Trigger\n\nclass RobotActivationService(Node):\n    def __init__(self):\n        super().__init__('robot_activation_service')\n\n        # Create service\n        # WHAT: This creates a service server that listens for activation requests\n        # WHY: Services are ideal for operations that need a definitive response, like activation\n        self.srv = self.create_service(\n            Trigger,\n            'activate_robot',\n            self.activate_robot_callback\n        )\n\n        self.is_active = False\n        self.get_logger().info('Robot Activation Service initialized')\n\n    def activate_robot_callback(self, request, response):\n        # Process the activation request\n        # WHAT: This callback handles incoming activation requests\n        # WHY: The callback defines how the service responds to requests\n        if not self.is_active:\n            # Simulate activation process\n            # WHAT: This simulates the steps needed to activate the robot\n            # WHY: Real activation would involve initializing actuators and sensors\n            self.get_logger().info('Activating robot...')\n\n            # In a real implementation, this would activate actuators,\n            # initialize sensors, etc.\n            self.is_active = True\n\n            # Set response values for successful activation\n            # WHAT: This sets the response to indicate success\n            # WHY: The service client needs to know if the operation was successful\n            response.success = True\n            response.message = 'Robot activated successfully'\n\n            self.get_logger().info('Robot activated successfully')\n        else:\n            # Handle case where robot is already active\n            # WHAT: This handles requests when the robot is already activated\n            # WHY: Prevents unnecessary activation attempts\n            response.success = False\n            response.message = 'Robot is already active'\n\n        return response\n\ndef main(args=None):\n    \"\"\"Main function to initialize and run the ROS 2 service node\"\"\"\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n    activation_service = RobotActivationService()\n\n    try:\n        # Start spinning the node to process service requests\n        # WHAT: This starts the ROS 2 event loop, processing incoming service requests\n        # WHY: Without spinning, the node wouldn't execute its service callback functions\n        rclpy.spin(activation_service)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        pass\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        activation_service.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dependencies"}),": ",(0,t.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,t.jsx)(n.code,{children:"example_interfaces"})]}),"\n",(0,t.jsx)(n.h3,{id:"example-2-action-for-navigation",children:"Example 2: Action for Navigation"}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of an action for humanoid navigation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Example: Navigation Action\n# WHAT: This code creates a ROS 2 action for humanoid navigation tasks\n# WHY: To demonstrate long-running tasks with feedback for robot movement\n\nimport rclpy\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile\nfrom geometry_msgs.msg import Point\nfrom nav2_msgs.action import NavigateToPose\nimport time\nimport math\n\nclass HumanoidNavigationAction(Node):\n    def __init__(self):\n        super().__init__('humanoid_navigation_action')\n\n        # Create action server\n        # WHAT: This creates an action server for navigation tasks\n        # WHY: Actions are ideal for long-running operations that require feedback and cancellation\n        self._action_server = ActionServer(\n            self,\n            NavigateToPose,\n            'navigate_to_pose',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback\n        )\n\n        self.get_logger().info('Humanoid Navigation Action server initialized')\n\n    def goal_callback(self, goal_request):\n        # Handle incoming navigation goals\n        # WHAT: This callback determines if a navigation goal should be accepted\n        # WHY: Allows the server to reject goals that are not feasible\n        self.get_logger().info('Received navigation goal')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        # Handle goal cancellation requests\n        # WHAT: This callback determines if a goal cancellation should be accepted\n        # WHY: Allows the server to control when goals can be cancelled\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        \"\"\"Execute the navigation goal\"\"\"\n        # Log the start of navigation execution\n        # WHAT: This logs that navigation has started\n        # WHY: Provides feedback on the action's progress for debugging\n        self.get_logger().info('Executing navigation goal...')\n\n        # Get target position from the goal request\n        # WHAT: This extracts the target coordinates from the goal\n        # WHY: The navigation algorithm needs to know where to go\n        target_x = goal_handle.request.pose.pose.position.x\n        target_y = goal_handle.request.pose.position.y\n\n        # Simulate navigation with feedback\n        # WHAT: This creates feedback and result messages for the action\n        # WHY: Actions require specific message types for feedback and results\n        feedback_msg = NavigateToPose.Feedback()\n        result = NavigateToPose.Result()\n\n        # Simulate moving toward the goal\n        # WHAT: This initializes the current position for the simulation\n        # WHY: Navigation starts from the current position\n        current_x, current_y = 0.0, 0.0  # Starting position\n        step_size = 0.1  # Meters per feedback step\n\n        # Navigation loop\n        # WHAT: This is the main loop that moves the robot toward the goal\n        # WHY: Continuous movement is needed until the goal is reached\n        while goal_handle.is_cancel_requested is False:\n            # Calculate distance to goal\n            # WHAT: This calculates how far the robot is from the target\n            # WHY: Needed to determine when the goal is reached\n            dist_to_goal = math.sqrt((target_x - current_x)**2 + (target_y - current_y)**2)\n\n            if dist_to_goal < 0.1:  # Close enough to goal\n                # Goal reached successfully\n                # WHAT: This indicates the navigation was successful\n                # WHY: The result message needs to indicate success or failure\n                result.result = True\n                goal_handle.succeed()\n                self.get_logger().info('Navigation completed successfully')\n                return result\n\n            # Move closer to goal\n            # WHAT: This calculates the direction and moves the robot\n            # WHY: The robot needs to continuously move toward the target\n            direction_x = (target_x - current_x) / dist_to_goal\n            direction_y = (target_y - current_y) / dist_to_goal\n\n            current_x += direction_x * step_size\n            current_y += direction_y * step_size\n\n            # Update feedback\n            # WHAT: This sends feedback to the action client about progress\n            # WHY: Clients need to know the current status of the long-running action\n            feedback_msg.current_pose.pose.position.x = current_x\n            feedback_msg.current_pose.pose.position.y = current_y\n            feedback_msg.distance_remaining = dist_to_goal\n\n            goal_handle.publish_feedback(feedback_msg)\n\n            # Sleep to simulate processing time\n            # WHAT: This simulates the time it takes to move the robot\n            # WHY: Real navigation would take actual time to execute\n            time.sleep(0.5)\n\n        # Check if goal was canceled\n        # WHAT: This handles the case where the goal was canceled\n        # WHY: The action needs to properly handle cancellation requests\n        if goal_handle.is_cancel_requested:\n            result.result = False\n            goal_handle.canceled()\n            self.get_logger().info('Navigation canceled')\n            return result\n\ndef main(args=None):\n    \"\"\"Main function to initialize and run the ROS 2 action server\"\"\"\n    # Initialize the ROS 2 client library\n    # WHAT: This initializes the rclpy library and prepares it for node creation\n    # WHY: All ROS 2 Python programs must initialize the client library before creating nodes\n    rclpy.init(args=args)\n    navigation_action = HumanoidNavigationAction()\n\n    try:\n        # Start spinning the node to process action requests\n        # WHAT: This starts the ROS 2 event loop, processing incoming action requests\n        # WHY: Without spinning, the node wouldn't execute its action callback functions\n        rclpy.spin(navigation_action)\n    except KeyboardInterrupt:\n        # Handle graceful shutdown when user interrupts the program\n        pass\n    finally:\n        # Clean up resources\n        # WHAT: This destroys the node and shuts down the rclpy library\n        # WHY: Proper cleanup is important to free resources and avoid potential issues\n        navigation_action.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dependencies"}),": ",(0,t.jsx)(n.code,{children:"rclpy"})," version Kilted Kaiju (2025), ",(0,t.jsx)(n.code,{children:"geometry_msgs"}),", ",(0,t.jsx)(n.code,{children:"nav2_msgs"})]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"In this chapter, we've covered the fundamental communication patterns in ROS 2:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nodes"}),": The basic computational units in ROS 2"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Topics"}),": For asynchronous publish-subscribe communication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Services"}),": For synchronous request-response communication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),": For long-running tasks with feedback"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These patterns form the foundation of the ROS 2 communication system and are essential for building complex humanoid robot applications. Each pattern has specific use cases, and choosing the right one for each situation is crucial for effective robot design."}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsx)(n.h3,{id:"conceptual",children:"Conceptual"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Compare and contrast the four ROS 2 communication patterns (nodes, topics, services, actions). When would you use each one in a humanoid robot system?"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"logical",children:"Logical"}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:"Design a communication architecture for a humanoid robot's walking controller. Which communication patterns would you use for each component (e.g., foot position tracking, balance control, step planning)?"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsx)(n.li,{children:"Implement a ROS 2 node that subscribes to joint states and publishes a simplified representation of the robot's posture (e.g., standing, sitting, walking). Include proper error handling and logging."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>r,x:()=>a});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);