"use strict";(globalThis.webpackChunkphysical_ai_book_humanoid=globalThis.webpackChunkphysical_ai_book_humanoid||[]).push([[2144],{2568(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-2-digital-twin/chapter-1-physics-simulation","title":"Physics Simulation in Gazebo","description":"Understanding physics simulation for digital twins using Gazebo","source":"@site/docs/module-2-digital-twin/chapter-1-physics-simulation.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/chapter-1-physics-simulation","permalink":"/textbook/docs/module-2-digital-twin/chapter-1-physics-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/Panaversity/physical_ai_book_humanoid/tree/main/docs/module-2-digital-twin/chapter-1-physics-simulation.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Physics Simulation in Gazebo","sidebar_position":2,"description":"Understanding physics simulation for digital twins using Gazebo","keywords":["physics simulation","gazebo","robotics simulation","collision detection"]},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Digital Twin","permalink":"/textbook/docs/module-2-digital-twin/intro"},"next":{"title":"Sensor Simulation in Gazebo","permalink":"/textbook/docs/module-2-digital-twin/chapter-2-sensor-simulation"}}');var o=i(4848),s=i(8453);const a={title:"Physics Simulation in Gazebo",sidebar_position:2,description:"Understanding physics simulation for digital twins using Gazebo",keywords:["physics simulation","gazebo","robotics simulation","collision detection"]},r="Chapter 1: Physics Simulation in Gazebo",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Newtonian Mechanics in Simulation",id:"newtonian-mechanics-in-simulation",level:3},{value:"Collision Detection and Response",id:"collision-detection-and-response",level:3},{value:"Numerical Integration",id:"numerical-integration",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Setting Up Gazebo Environment",id:"setting-up-gazebo-environment",level:3},{value:"Physics Properties Configuration",id:"physics-properties-configuration",level:3},{value:"Physics Parameter Tuning",id:"physics-parameter-tuning",level:3},{value:"Examples",id:"examples",level:2},{value:"Example 1: Gravity Compensation Test",id:"example-1-gravity-compensation-test",level:3},{value:"Example 2: Collision Detection Validation",id:"example-2-collision-detection-validation",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Conceptual",id:"conceptual",level:3},{value:"Logical",id:"logical",level:3},{value:"Implementation",id:"implementation-1",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"chapter-1-physics-simulation-in-gazebo",children:"Chapter 1: Physics Simulation in Gazebo"})}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Explain the fundamental physics principles underlying robot simulation"}),"\n",(0,o.jsx)(e.li,{children:"Configure Gazebo simulation environments with accurate physics parameters"}),"\n",(0,o.jsx)(e.li,{children:"Implement collision detection and response mechanisms"}),"\n",(0,o.jsx)(e.li,{children:"Tune physics parameters for realistic robot behavior in simulation"}),"\n",(0,o.jsx)(e.li,{children:"Compare simulation results with real-world robot performance"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsx)(e.p,{children:"Students should have:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Understanding of basic physics concepts (gravity, friction, momentum)"}),"\n",(0,o.jsx)(e.li,{children:"Basic knowledge of ROS 2 communication (covered in Module 1)"}),"\n",(0,o.jsx)(e.li,{children:"Familiarity with coordinate systems and transformations"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,o.jsx)(e.p,{children:"Physics simulation in robotics relies on numerical integration of differential equations that describe motion. The key components include:"}),"\n",(0,o.jsx)(e.h3,{id:"newtonian-mechanics-in-simulation",children:"Newtonian Mechanics in Simulation"}),"\n",(0,o.jsx)(e.p,{children:"The simulation engine calculates forces acting on each rigid body and integrates Newton's equations of motion:\n$$F = ma$$\n$$\\tau = I\\alpha$$"}),"\n",(0,o.jsx)(e.p,{children:"Where:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"$F$ is the net force applied to a body"}),"\n",(0,o.jsx)(e.li,{children:"$m$ is the mass of the body"}),"\n",(0,o.jsx)(e.li,{children:"$a$ is the resulting acceleration"}),"\n",(0,o.jsx)(e.li,{children:"$\\tau$ is the torque applied"}),"\n",(0,o.jsx)(e.li,{children:"$I$ is the moment of inertia"}),"\n",(0,o.jsx)(e.li,{children:"$\\alpha$ is the angular acceleration"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"collision-detection-and-response",children:"Collision Detection and Response"}),"\n",(0,o.jsx)(e.p,{children:"Simulation engines use various algorithms to detect and respond to collisions:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Broad phase: Quick elimination of non-colliding pairs"}),"\n",(0,o.jsx)(e.li,{children:"Narrow phase: Precise collision detection between potentially colliding objects"}),"\n",(0,o.jsx)(e.li,{children:"Contact resolution: Calculation of forces to prevent penetration"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"numerical-integration",children:"Numerical Integration"}),"\n",(0,o.jsx)(e.p,{children:"Simulators use numerical methods to approximate the continuous motion of bodies:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Euler integration (simple but unstable)"}),"\n",(0,o.jsx)(e.li,{children:"Runge-Kutta methods (more accurate)"}),"\n",(0,o.jsx)(e.li,{children:"Verlet integration (stable for constraints)"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"implementation",children:"Implementation"}),"\n",(0,o.jsx)(e.p,{children:"Let's implement a basic physics simulation using Gazebo. We'll create a simple humanoid robot model and configure its physical properties."}),"\n",(0,o.jsx)(e.h3,{id:"setting-up-gazebo-environment",children:"Setting Up Gazebo Environment"}),"\n",(0,o.jsx)(e.p,{children:"First, let's create a launch file to start Gazebo with our custom world:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:"\x3c!-- launch/humanoid_sim.launch.py --\x3e\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    pkg_gazebo_ros = get_package_share_directory('gazebo_ros')\n\n    world_file = os.path.join(\n        get_package_share_directory('humanoid_simulation'),\n        'worlds',\n        'humanoid_world.world'\n    )\n\n    return LaunchDescription([\n        # Launch Gazebo with our world\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource(\n                os.path.join(pkg_gazebo_ros, 'launch', 'gazebo.launch.py')\n            ),\n            launch_arguments={\n                'world': world_file,\n                'verbose': 'true'\n            }.items()\n        ),\n\n        # Spawn our robot in the simulation\n        Node(\n            package='gazebo_ros',\n            executable='spawn_entity.py',\n            arguments=[\n                '-entity', 'humanoid_robot',\n                '-file', os.path.join(get_package_share_directory('humanoid_description'), 'urdf', 'humanoid.urdf'),\n                '-x', '0', '-y', '0', '-z', '1.0'\n            ],\n            output='screen'\n        )\n    ])\n"})}),"\n",(0,o.jsx)(e.h3,{id:"physics-properties-configuration",children:"Physics Properties Configuration"}),"\n",(0,o.jsx)(e.p,{children:"The physical properties of our robot are defined in the URDF file with SDF extensions for Gazebo-specific parameters:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- URDF snippet with Gazebo physics --\x3e\n<link name="torso">\n  <inertial>\n    <mass value="10.0"/>\n    <origin xyz="0 0 0.2" rpy="0 0 0"/>\n    <inertia ixx="0.5" ixy="0.0" ixz="0.0"\n             iyy="0.5" iyz="0.0"\n             izz="0.5"/>\n  </inertial>\n\n  <visual>\n    <geometry>\n      <mesh filename="package://humanoid_description/meshes/torso.stl"/>\n    </geometry>\n  </visual>\n\n  <collision>\n    <geometry>\n      <mesh filename="package://humanoid_description/meshes/torso_collision.stl"/>\n    </geometry>\n  </collision>\n</link>\n\n<gazebo reference="torso">\n  <mu1>0.8</mu1>  \x3c!-- Friction coefficient --\x3e\n  <mu2>0.8</mu2>  \x3c!-- Secondary friction coefficient --\x3e\n  <kp>1000000.0</kp>  \x3c!-- Contact stiffness --\x3e\n  <kd>100.0</kd>      \x3c!-- Contact damping --\x3e\n  <material>Gazebo/Orange</material>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"physics-parameter-tuning",children:"Physics Parameter Tuning"}),"\n",(0,o.jsx)(e.p,{children:"Different scenarios require different physics parameters:"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"High Precision Applications (Manipulation):"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Small time steps (1ms or less)"}),"\n",(0,o.jsx)(e.li,{children:"High solver iterations (100+)"}),"\n",(0,o.jsx)(e.li,{children:"Accurate collision geometry"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Fast Prototyping:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Larger time steps (5-10ms)"}),"\n",(0,o.jsx)(e.li,{children:"Lower solver iterations (50-100)"}),"\n",(0,o.jsx)(e.li,{children:"Simplified collision geometry"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"examples",children:"Examples"}),"\n",(0,o.jsx)(e.h3,{id:"example-1-gravity-compensation-test",children:"Example 1: Gravity Compensation Test"}),"\n",(0,o.jsx)(e.p,{children:"Let's create a simple test to verify our physics simulation is working correctly:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n# test_gravity_compensation.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray\nfrom sensor_msgs.msg import JointState\nimport numpy as np\n\nclass GravityCompensationTest(Node):\n    \"\"\"Test gravity compensation in simulation\"\"\"\n\n    def __init__(self):\n        super().__init__('gravity_compensation_test')\n\n        # Publisher for joint commands\n        self.joint_cmd_pub = self.create_publisher(\n            Float64MultiArray,\n            '/joint_group_position_controller/commands',\n            10\n        )\n\n        # Subscriber for joint states\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        # Timer to send commands\n        self.timer = self.create_timer(0.1, self.test_callback)\n        self.joint_names = ['hip_joint', 'knee_joint', 'ankle_joint']\n\n        self.get_logger().info('Gravity compensation test node started')\n\n    def test_callback(self):\n        \"\"\"Send zero torques and observe drift due to imperfect simulation\"\"\"\n        cmd_msg = Float64MultiArray()\n        cmd_msg.data = [0.0, 0.0, 0.0]  # Zero torque command\n        self.joint_cmd_pub.publish(cmd_msg)\n\n    def joint_state_callback(self, msg):\n        \"\"\"Process joint state feedback\"\"\"\n        # Log positions to observe drift over time\n        for name, pos in zip(msg.name, msg.position):\n            if name in self.joint_names:\n                self.get_logger().info(f'{name}: {pos:.4f}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    test_node = GravityCompensationTest()\n\n    try:\n        rclpy.spin(test_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        test_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(e.h3,{id:"example-2-collision-detection-validation",children:"Example 2: Collision Detection Validation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n# collision_validation.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PointStamped\nfrom visualization_msgs.msg import Marker\nfrom tf2_ros import TransformListener, Buffer\nimport tf2_geometry_msgs\n\nclass CollisionValidator(Node):\n    \"\"\"Validate collision detection by monitoring distance to obstacles\"\"\"\n\n    def __init__(self):\n        super().__init__('collision_validator')\n\n        # TF listener to get robot pose\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # Publishers for visualization\n        self.marker_pub = self.create_publisher(Marker, 'collision_distance', 10)\n        self.safety_pub = self.create_publisher(PointStamped, 'safety_zone', 10)\n\n        # Timer to check distances\n        self.timer = self.create_timer(0.5, self.check_distances)\n\n        # Define obstacle positions (should match your world file)\n        self.obstacles = [\n            {'name': 'wall1', 'position': [2.0, 0.0, 0.0]},\n            {'name': 'obstacle1', 'position': [1.0, 1.0, 0.0]}\n        ]\n\n        self.robot_frame = 'base_link'\n        self.world_frame = 'world'\n\n    def check_distances(self):\n        \"\"\"Check distance from robot to obstacles\"\"\"\n        try:\n            # Get robot transform\n            t = self.tf_buffer.lookup_transform(\n                self.world_frame,\n                self.robot_frame,\n                rclpy.time.Time()\n            )\n\n            robot_pos = [t.transform.translation.x,\n                        t.transform.translation.y,\n                        t.transform.translation.z]\n\n            min_distance = float('inf')\n            closest_obstacle = None\n\n            for obs in self.obstacles:\n                dist = np.linalg.norm(np.array(robot_pos[:2]) - np.array(obs['position'][:2]))\n                if dist < min_distance:\n                    min_distance = dist\n                    closest_obstacle = obs['name']\n\n            # Log safety information\n            if min_distance < 0.5:  # Less than 50cm to obstacle\n                self.get_logger().warn(f'CLOSE TO OBSTACLE: {closest_obstacle}, distance: {min_distance:.2f}m')\n            elif min_distance < 1.0:\n                self.get_logger().info(f'NEAR OBSTACLE: {closest_obstacle}, distance: {min_distance:.2f}m')\n            else:\n                self.get_logger().info(f'SAFE DISTANCE: {min_distance:.2f}m from {closest_obstacle}')\n\n        except Exception as e:\n            self.get_logger().error(f'Transform lookup failed: {str(e)}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    validator = CollisionValidator()\n\n    try:\n        rclpy.spin(validator)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        validator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Physics simulation forms the foundation of digital twin technology in robotics. Properly configured physics engines like Gazebo enable safe testing of robot behaviors before real-world deployment. Key considerations include:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Accuracy vs. Performance"}),": Balance realistic physics with computational efficiency"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Parameter Tuning"}),": Adjust friction, damping, and stiffness to match real-world behavior"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Validation"}),": Continuously compare simulation results with real robot performance"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Safety"}),": Use simulation to test dangerous scenarios without risk to equipment or personnel"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsx)(e.h3,{id:"conceptual",children:"Conceptual"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Explain why physics simulation is crucial for robotics development and how it relates to the concept of digital twins."}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"logical",children:"Logical"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Analyze the trade-offs between simulation accuracy and computational performance. When would you prioritize one over the other?"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Create a Gazebo simulation with a humanoid robot and implement a simple physics validation test that measures how closely the simulated robot behaves to theoretical physics predictions."}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>a,x:()=>r});var t=i(6540);const o={},s=t.createContext(o);function a(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);